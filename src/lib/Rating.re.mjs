// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Session from "./Session.re.mjs";
import * as Openskill from "openskill";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.re.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.re.mjs";
import * as Core__String from "@rescript/core/src/Core__String.re.mjs";
import * as PlackettLuceTs from "../lib/rating/models/plackettLuce.ts";

var plackettLuce = PlackettLuceTs.plackettLuce;

var RatingModel = {
  plackettLuce: plackettLuce
};

function makeGuest(name) {
  return {
          name: name,
          picture: undefined
        };
}

function get_rating(t) {
  return t.mu;
}

function make(mu, sigma) {
  return Openskill.rating({
              mu: mu,
              sigma: sigma
            });
}

function makeDefault() {
  return Openskill.rating(undefined);
}

function Rating_predictDraw(prim) {
  return Openskill.predictDraw(prim);
}

function Rating_ordinal(prim) {
  return Openskill.ordinal(prim);
}

function Rating_rate(prim0, prim1) {
  return Openskill.rate(prim0, prim1 !== undefined ? Caml_option.valFromOption(prim1) : undefined);
}

var Rating = {
  get_rating: get_rating,
  make: make,
  makeDefault: makeDefault,
  predictDraw: Rating_predictDraw,
  ordinal: Rating_ordinal,
  rate: Rating_rate
};

function makeDefaultRatingPlayer(name) {
  var rating = Openskill.rating(undefined);
  return {
          data: undefined,
          id: "guest-" + name,
          name: name,
          rating: rating,
          ratingOrdinal: Rating_ordinal(rating),
          paid: false
        };
}

var Player = {
  makeDefaultRatingPlayer: makeDefaultRatingPlayer
};

function contains_player(players, player) {
  var players$1 = new Set(players.map(function (p) {
            return p.id;
          }));
  return players$1.has(player.id);
}

function toSet(team) {
  return new Set(team.map(function (p) {
                  return p.id;
                }));
}

function is_equal_to(t1, t2) {
  var t1$1 = new Set(t1.map(function (p) {
            return p.id;
          }));
  var t2$1 = new Set(t2.map(function (p) {
            return p.id;
          }));
  return t1$1.intersection(t2$1).size === t1$1.size;
}

function toStableId(t) {
  return t.map(function (p) {
                  return p.id;
                }).toSorted(Core__String.compare).join("-");
}

var Team = {
  contains_player: contains_player,
  toSet: toSet,
  is_equal_to: is_equal_to,
  toStableId: toStableId
};

function is_equal_to$1(t1, t2) {
  return t1.intersection(t2).size === t1.size;
}

function containsAllOf(t1, t2) {
  return t2.intersection(t1).size === t2.size;
}

var TeamSet = {
  is_equal_to: is_equal_to$1,
  containsAllOf: containsAllOf
};

function contains_player$1(param, player) {
  if (contains_player(param[0], player)) {
    return true;
  } else {
    return contains_player(param[1], player);
  }
}

function contains_any_players(param, players) {
  var players$1 = new Set(players.map(function (p) {
            return p.id;
          }));
  var match_players = new Set([
            param[0],
            param[1]
          ].map(function (t) {
              return t.map(function (p) {
                          return p.id;
                        });
            }).flatMap(function (x) {
            return x;
          }));
  return match_players.intersection(players$1).size > 0;
}

function contains_all_players(param, players) {
  var players$1 = new Set(players.map(function (p) {
            return p.id;
          }));
  var match_players = new Set([
            param[0],
            param[1]
          ].map(function (t) {
              return t.map(function (p) {
                          return p.id;
                        });
            }).flatMap(function (x) {
            return x;
          }));
  return players$1.intersection(match_players).size === players$1.size;
}

function rate(param) {
  var losers = param[1];
  var winners = param[0];
  return Belt_Array.zipBy(Rating_rate([
                    winners,
                    losers
                  ].map(function (__x) {
                      return __x.map(function (player) {
                                  return player.rating;
                                });
                    }), Caml_option.some({
                      model: plackettLuce
                    })), [
              winners,
              losers
            ], (function (new_ratings, old_teams) {
                return Belt_Array.zipBy(new_ratings, old_teams, (function (new_rating, old_player) {
                              return {
                                      data: old_player.data,
                                      id: old_player.id,
                                      name: old_player.name,
                                      rating: new_rating,
                                      ratingOrdinal: old_player.ratingOrdinal,
                                      paid: old_player.paid
                                    };
                            }));
              }));
}

function toStableId$1(param) {
  return [
              toStableId(param[0]),
              toStableId(param[1])
            ].toSorted(Core__String.compare).join("-");
}

function players(param) {
  return [
            param[0],
            param[1]
          ].flatMap(function (x) {
              return x;
            });
}

var Match = {
  contains_player: contains_player$1,
  contains_any_players: contains_any_players,
  contains_all_players: contains_all_players,
  rate: rate,
  toStableId: toStableId$1,
  players: players
};

function submit(param, activitySlug, submitMatch) {
  var score = param[1];
  if (score !== undefined) {
    return submitMatch(param[0], [
                score[0],
                score[1]
              ], activitySlug);
  } else {
    return Promise.resolve();
  }
}

function toStableId$2(param) {
  return toStableId$1(param[0]);
}

var CompletedMatch = {
  submit: submit,
  toStableId: toStableId$2
};

function getLastPlayedPlayers(matches, restCount, availablePlayers) {
  var playersCount = availablePlayers - restCount | 0;
  var teams = matches.toReversed().flatMap(function (param) {
        var match = param[0];
        return [
                match[0],
                match[1]
              ];
      });
  return teams.flatMap(function (p) {
                return p;
              }).slice(0, playersCount);
}

function getlastRoundMatches(matches, restCount, availablePlayers, playersPerMatch) {
  var lastPlayedCount = getLastPlayedPlayers(matches, restCount, availablePlayers).length;
  var matchesPlayed = Caml_int32.div(lastPlayedCount, playersPerMatch);
  return matches.toReversed().slice(0, matchesPlayed);
}

function saveMatches(t, namespace) {
  var t$1 = t.map(function (param) {
        var match = param[0];
        return [
                [
                  match[0].map(function (p) {
                        return p.id;
                      }),
                  match[1].map(function (p) {
                        return p.id;
                      })
                ],
                param[1]
              ];
      });
  localStorage.setItem(namespace + "-matchesState", Core__Option.getOr(JSON.stringify(t$1), ""));
}

function loadMatches(namespace, players) {
  var players$1 = Core__Array.reduce(players, {}, (function (acc, player) {
          acc[player.id] = player;
          return acc;
        }));
  var state = localStorage.getItem(namespace + "-matchesState");
  return Core__Array.filterMap((
                state !== null ? JSON.parse(state) : []
              ).map(function (param) {
                  var match = param[0];
                  var score = Caml_option.nullable_to_opt(param[1]);
                  return [
                          [
                            Core__Array.reduce(match[0].map(function (p) {
                                      return Js_dict.get(players$1, p);
                                    }), [], (function (acc, player) {
                                    return Core__Option.flatMap(acc, (function (acc) {
                                                  if (player !== undefined) {
                                                    return acc.concat([player]);
                                                  }
                                                  
                                                }));
                                  })),
                            Core__Array.reduce(match[1].map(function (p) {
                                      return Js_dict.get(players$1, p);
                                    }), [], (function (acc, player) {
                                    return Core__Option.flatMap(acc, (function (acc) {
                                                  if (player !== undefined) {
                                                    return acc.concat([player]);
                                                  }
                                                  
                                                }));
                                  }))
                          ],
                          score
                        ];
                }), (function (param) {
                var match = param[0];
                var team2 = match[1];
                var team1 = match[0];
                if (team1 !== undefined && team2 !== undefined) {
                  return [
                          [
                            team1,
                            team2
                          ],
                          param[1]
                        ];
                }
                
              }));
}

var CompletedMatches = {
  getLastPlayedPlayers: getLastPlayedPlayers,
  getlastRoundMatches: getlastRoundMatches,
  saveMatches: saveMatches,
  loadMatches: loadMatches
};

function fromTeam(team) {
  if (team.length !== 2) {
    return {
            TAG: "Error",
            _0: "TwoPlayersRequired"
          };
  }
  var p1 = team[0];
  var p2 = team[1];
  return {
          TAG: "Ok",
          _0: [
            p1,
            p2
          ]
        };
}

var DoublesTeam = {
  fromTeam: fromTeam
};

function fromMatch(param) {
  var t1 = fromTeam(param[0]);
  var t2 = fromTeam(param[1]);
  if (t1.TAG === "Ok") {
    if (t2.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: [
                t1._0,
                t2._0
              ]
            };
    } else {
      return {
              TAG: "Error",
              _0: t2._0
            };
    }
  } else {
    return {
            TAG: "Error",
            _0: t1._0
          };
  }
}

var DoublesMatch = {
  fromMatch: fromMatch
};

function sortByRatingDesc(t) {
  return t.toSorted(function (a, b) {
              var userA = a.rating.mu;
              var userB = b.rating.mu;
              if (userA < userB) {
                return 1;
              } else {
                return -1;
              }
            });
}

function sortByPlayCountAsc(t, session) {
  return t.toSorted(function (a, b) {
              if (Session.get(session, a.id).count < Session.get(session, b.id).count) {
                return -1;
              } else {
                return 1;
              }
            });
}

function sortByPlayCountDesc(t, session) {
  return t.toSorted(function (a, b) {
              if (Session.get(session, a.id).count < Session.get(session, b.id).count) {
                return 1;
              } else {
                return -1;
              }
            });
}

function sortByOrdinalDesc(t) {
  return t.toSorted(function (a, b) {
              if (a.ratingOrdinal < b.ratingOrdinal) {
                return 1;
              } else {
                return -1;
              }
            });
}

function filterOut(players, unavailable) {
  return players.filter(function (p) {
              return !unavailable.has(p.id);
            });
}

function addBreakPlayersFrom(breakPlayers, players, breakCount) {
  return filterOut(players, new Set(breakPlayers.map(function (p) {
                          return p.id;
                        }))).slice(0, breakCount - breakPlayers.length | 0).concat(breakPlayers);
}

function savePlayers(t, namespace) {
  var t$1 = t.map(function (p) {
        return {
                data: undefined,
                id: p.id,
                name: p.name,
                rating: p.rating,
                ratingOrdinal: p.ratingOrdinal,
                paid: p.paid
              };
      });
  var t$2 = Core__Array.reduce(t$1, {}, (function (acc, player) {
          acc[player.id] = player;
          return acc;
        }));
  localStorage.setItem(namespace + "-playersState", Core__Option.getOr(JSON.stringify(t$2), ""));
}

function loadPlayers(players, namespace) {
  var state = localStorage.getItem(namespace + "-playersState");
  var storage = state !== null ? JSON.parse(state) : ({});
  return players.map(function (p) {
              return Core__Option.getOr(Core__Option.map(Js_dict.get(storage, p.id), (function (store) {
                                return {
                                        data: p.data,
                                        id: store.id,
                                        name: store.name,
                                        rating: store.rating,
                                        ratingOrdinal: store.ratingOrdinal,
                                        paid: store.paid
                                      };
                              })), p);
            });
}

var Players = {
  sortByRatingDesc: sortByRatingDesc,
  sortByPlayCountAsc: sortByPlayCountAsc,
  sortByPlayCountDesc: sortByPlayCountDesc,
  sortByOrdinalDesc: sortByOrdinalDesc,
  filterOut: filterOut,
  addBreakPlayersFrom: addBreakPlayersFrom,
  savePlayers: savePlayers,
  loadPlayers: loadPlayers
};

function fromPlayers(players) {
  return Js_dict.fromArray(players.map(function (p) {
                  return [
                          p.id,
                          p
                        ];
                }));
}

var get = Js_dict.get;

var PlayersCache = {
  fromPlayers: fromPlayers,
  get: get
};

function toDndItems(t) {
  return Js_dict.fromArray(t.map(function (param) {
                      return [
                              param[0],
                              param[1]
                            ];
                    }).flatMap(function (x) {
                    return x;
                  }).map(function (team, i) {
                  return [
                          i.toString(),
                          team.map(function (p) {
                                return p.id;
                              })
                        ];
                }));
}

function fromDndItems(items, playersCache) {
  return Core__Array.reduce(Js_dict.entries(items).map(function (param) {
                    var players = param[1].map(function (p) {
                          return Js_dict.get(playersCache, p);
                        });
                    return Core__Array.filterMap(players, (function (x) {
                                  return x;
                                }));
                  }), [
                [],
                [
                  undefined,
                  undefined
                ]
              ], (function (param, team) {
                  var buildingMatch = param[1];
                  var t1 = buildingMatch[0];
                  var matches = param[0];
                  if (t1 !== undefined) {
                    var t2 = buildingMatch[1];
                    if (t2 !== undefined) {
                      return [
                              matches.concat([[
                                      t1,
                                      t2
                                    ]]),
                              [
                                team,
                                undefined
                              ]
                            ];
                    } else {
                      return [
                              matches.concat([[
                                      t1,
                                      team
                                    ]]),
                              [
                                undefined,
                                undefined
                              ]
                            ];
                    }
                  }
                  var t2$1 = buildingMatch[1];
                  if (t2$1 !== undefined) {
                    return [
                            matches.concat([[
                                    team,
                                    t2$1
                                  ]]),
                            [
                              undefined,
                              undefined
                            ]
                          ];
                  } else {
                    return [
                            matches,
                            [
                              team,
                              undefined
                            ]
                          ];
                  }
                }))[0];
}

var Matches = {
  toDndItems: toDndItems,
  fromDndItems: fromDndItems
};

export {
  RatingModel ,
  makeGuest ,
  Rating ,
  Player ,
  Team ,
  TeamSet ,
  Match ,
  CompletedMatch ,
  CompletedMatches ,
  DoublesTeam ,
  DoublesMatch ,
  Players ,
  PlayersCache ,
  Matches ,
}
/* plackettLuce Not a pure module */
