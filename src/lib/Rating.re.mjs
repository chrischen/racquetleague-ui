// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Util from "../components/shared/Util.re.mjs";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as KMeans from "./KMeans.re.mjs";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Js_math from "rescript/lib/es6/js_math.js";
import * as Session from "./Session.re.mjs";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Openskill from "openskill";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.re.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.re.mjs";
import * as Core__String from "@rescript/core/src/Core__String.re.mjs";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";
import * as LzString from "@immutabl3/lz-string";
import * as KMeansClusteringJs from "k-means-clustering-js";
import * as Json_Decode$JsonCombinators from "@glennsl/rescript-json-combinators/src/Json_Decode.re.mjs";
import * as PlackettLuceTs from "../lib/rating/models/plackettLuce.ts";

var plackettLuce = PlackettLuceTs.plackettLuce;

var RatingModel = {
  plackettLuce: plackettLuce
};

function toInt(gender) {
  if (gender === "Male") {
    return 1;
  } else {
    return 0;
  }
}

function fromInt($$int) {
  if ($$int !== 0) {
    return "Male";
  } else {
    return "Female";
  }
}

var Gender = {
  toInt: toInt,
  fromInt: fromInt
};

function makeGuest(name) {
  return {
          name: name,
          picture: undefined
        };
}

function get_rating(t) {
  return t.mu;
}

function make(mu, sigma) {
  return Openskill.rating({
              mu: mu,
              sigma: sigma
            });
}

function makeDefault() {
  return Openskill.rating(undefined);
}

function decay_by_factor(t, factor) {
  var diff = 8.333333 - t.sigma;
  var decay = factor * diff;
  var sigma = t.sigma + decay;
  return make(t.mu, sigma);
}

function Rating_predictDraw(prim) {
  return Openskill.predictDraw(prim);
}

function Rating_predictWin(prim) {
  return Openskill.predictWin(prim);
}

function Rating_ordinal(prim) {
  return Openskill.ordinal(prim);
}

function Rating_rate(prim0, prim1) {
  return Openskill.rate(prim0, prim1 !== undefined ? Caml_option.valFromOption(prim1) : undefined);
}

var Rating = {
  get_rating: get_rating,
  make: make,
  makeDefault: makeDefault,
  predictDraw: Rating_predictDraw,
  predictWin: Rating_predictWin,
  ordinal: Rating_ordinal,
  rate: Rating_rate,
  decay_by_factor: decay_by_factor
};

function makeDefaultRatingPlayer(name, gender, intId) {
  var rating = Openskill.rating(undefined);
  return {
          data: undefined,
          id: "guest-" + name,
          intId: intId,
          name: name,
          rating: rating,
          ratingOrdinal: Rating_ordinal(rating),
          paid: false,
          gender: gender,
          count: 0
        };
}

function toDb(player) {
  var row = {};
  row["playerId"] = player.id;
  row["intId"] = player.intId;
  row["name"] = player.name;
  row["ratingMu"] = player.rating.mu;
  row["ratingSigma"] = player.rating.sigma;
  row["genderInt"] = toInt(player.gender);
  row["paid"] = player.paid;
  row["count"] = player.count;
  return row;
}

function fromDb(row) {
  var match = Core__Option.flatMap(Js_dict.get(row, "playerId"), Js_json.decodeString);
  var match$1 = Core__Option.flatMap(Js_dict.get(row, "intId"), Js_json.decodeNumber);
  var match$2 = Core__Option.flatMap(Js_dict.get(row, "name"), Js_json.decodeString);
  var match$3 = Core__Option.flatMap(Js_dict.get(row, "ratingMu"), Js_json.decodeNumber);
  var match$4 = Core__Option.flatMap(Js_dict.get(row, "ratingSigma"), Js_json.decodeNumber);
  var match$5 = Core__Option.flatMap(Js_dict.get(row, "genderInt"), Js_json.decodeNumber);
  if (match !== undefined && match$1 !== undefined && match$2 !== undefined && match$3 !== undefined && match$4 !== undefined && match$5 !== undefined) {
    return {
            data: undefined,
            id: match,
            intId: match$1 | 0,
            name: match$2,
            rating: {
              mu: match$3,
              sigma: match$4
            },
            ratingOrdinal: 0,
            paid: Core__Option.getOr(Core__Option.flatMap(Js_dict.get(row, "paid"), Js_json.decodeBoolean), false),
            gender: fromInt(match$5 | 0),
            count: Core__Option.getOr(Core__Option.map(Core__Option.flatMap(Js_dict.get(row, "count"), Js_json.decodeNumber), (function (prim) {
                        return prim | 0;
                      })), 0)
          };
  }
  
}

function decodePlayer() {
  return Json_Decode$JsonCombinators.object(function (field) {
              var decodeRating = Json_Decode$JsonCombinators.object(function (field) {
                    var mu = field.required("mu", Json_Decode$JsonCombinators.$$float);
                    var sigma = field.required("sigma", Json_Decode$JsonCombinators.$$float);
                    return make(mu, sigma);
                  });
              var decodeGender = Json_Decode$JsonCombinators.map(Json_Decode$JsonCombinators.$$int, fromInt);
              var id = field.required("id", Json_Decode$JsonCombinators.string);
              var intId = field.required("intId", Json_Decode$JsonCombinators.$$int);
              var name = field.required("name", Json_Decode$JsonCombinators.string);
              var rating = field.required("rating", decodeRating);
              var ratingOrdinal = field.required("ratingOrdinal", Json_Decode$JsonCombinators.$$float);
              var paid = field.required("paid", Json_Decode$JsonCombinators.bool);
              var gender = field.required("gender", decodeGender);
              var count = Core__Option.getOr(field.optional("count", Json_Decode$JsonCombinators.$$int), 0);
              return {
                      data: undefined,
                      id: id,
                      intId: intId,
                      name: name,
                      rating: rating,
                      ratingOrdinal: ratingOrdinal,
                      paid: paid,
                      gender: gender,
                      count: count
                    };
            });
}

function toJson(player) {
  var obj = {};
  obj["id"] = player.id;
  obj["intId"] = player.intId;
  obj["name"] = player.name;
  var ratingObj = {};
  ratingObj["mu"] = player.rating.mu;
  ratingObj["sigma"] = player.rating.sigma;
  obj["rating"] = ratingObj;
  obj["ratingOrdinal"] = player.ratingOrdinal;
  obj["paid"] = player.paid;
  obj["gender"] = toInt(player.gender);
  obj["count"] = player.count;
  return obj;
}

function toJsonString(player) {
  return Core__Option.getOr(JSON.stringify(toJson(player)), "{}");
}

function fromJson(json) {
  var player = Json_Decode$JsonCombinators.decode(json, decodePlayer());
  if (player.TAG === "Ok") {
    return player._0;
  }
  console.log("[Player.fromJson] Decode error:", player._0);
}

function fromJsonString(jsonStr) {
  try {
    var json = JSON.parse(jsonStr);
    return fromJson(json);
  }
  catch (exn){
    console.log("[Player.fromJsonString] Failed to parse:", jsonStr);
    return ;
  }
}

var Player = {
  makeDefaultRatingPlayer: makeDefaultRatingPlayer,
  toDb: toDb,
  fromDb: fromDb,
  decodePlayer: decodePlayer,
  toJson: toJson,
  toJsonString: toJsonString,
  fromJson: fromJson,
  fromJsonString: fromJsonString
};

function contains_player(players, player) {
  var players$1 = new Set(players.map(function (p) {
            return p.id;
          }));
  return players$1.has(player.id);
}

function toSet(team) {
  return new Set(team.map(function (p) {
                  return p.id;
                }));
}

function is_equal_to(t1, t2) {
  var t1$1 = new Set(t1.map(function (p) {
            return p.id;
          }));
  var t2$1 = new Set(t2.map(function (p) {
            return p.id;
          }));
  return t1$1.intersection(t2$1).size === t1$1.size;
}

function toStableId(t) {
  return t.map(function (p) {
                  return p.id;
                }).toSorted(Core__String.compare).join("-");
}

function toDb$1(team) {
  return team.map(function (player) {
              return toDb(player);
            });
}

var Team = {
  contains_player: contains_player,
  toSet: toSet,
  is_equal_to: is_equal_to,
  toStableId: toStableId,
  toDb: toDb$1
};

function make$1() {
  return new Map();
}

function setLastRound(dict, teamId, roundNumber) {
  dict.set(teamId, roundNumber);
}

function setMatchLastRound(dict, team1Id, team2Id, roundNumber) {
  setLastRound(dict, team1Id, roundNumber);
  setLastRound(dict, team2Id, roundNumber);
}

function getLastRound(dict, teamId) {
  return Core__Option.getOr(dict.get(teamId), 0);
}

function getMatchScore(dict, team1Id, team2Id) {
  return getLastRound(dict, team1Id) + getLastRound(dict, team2Id) | 0;
}

function fromHistory(history, getTeams, matchesPerRound) {
  var dict = new Map();
  history.forEach(function (match, index) {
        var match$1 = getTeams(match);
        var roundNumber = Caml_int32.div(index, matchesPerRound) + 1 | 0;
        setMatchLastRound(dict, match$1[0], match$1[1], roundNumber);
      });
  return dict;
}

var TeamCountDict = {
  make: make$1,
  setLastRound: setLastRound,
  setMatchLastRound: setMatchLastRound,
  getLastRound: getLastRound,
  getMatchScore: getMatchScore,
  fromHistory: fromHistory
};

function is_equal_to$1(t1, t2) {
  return t1.intersection(t2).size === t1.size;
}

function containsAllOf(t1, t2) {
  return t2.intersection(t1).size === t2.size;
}

var TeamSet = {
  is_equal_to: is_equal_to$1,
  containsAllOf: containsAllOf
};

function contains_player$1(param, player) {
  if (contains_player(param[0], player)) {
    return true;
  } else {
    return contains_player(param[1], player);
  }
}

function contains_any_players(param, players) {
  var players$1 = new Set(players.map(function (p) {
            return p.id;
          }));
  var match_players = new Set([
            param[0],
            param[1]
          ].map(function (t) {
              return t.map(function (p) {
                          return p.id;
                        });
            }).flatMap(function (x) {
            return x;
          }));
  return match_players.intersection(players$1).size > 0;
}

function contains_all_players(param, players) {
  var players$1 = new Set(players.map(function (p) {
            return p.id;
          }));
  var match_players = new Set([
            param[0],
            param[1]
          ].map(function (t) {
              return t.map(function (p) {
                          return p.id;
                        });
            }).flatMap(function (x) {
            return x;
          }));
  return players$1.intersection(match_players).size === players$1.size;
}

function contains_more_than_1_players(param, players) {
  var players$1 = new Set(players.map(function (p) {
            return p.id;
          }));
  var match_players = new Set([
            param[0],
            param[1]
          ].map(function (t) {
              return t.map(function (p) {
                          return p.id;
                        });
            }).flatMap(function (x) {
            return x;
          }));
  return match_players.intersection(players$1).size > 1;
}

function rate(param) {
  var losers = param[1];
  var winners = param[0];
  return Belt_Array.zipBy(Rating_rate([
                    winners,
                    losers
                  ].map(function (__x) {
                      return __x.map(function (player) {
                                  return player.rating;
                                });
                    }), Caml_option.some({
                      model: plackettLuce
                    })), [
              winners,
              losers
            ], (function (new_ratings, old_teams) {
                return Belt_Array.zipBy(new_ratings, old_teams, (function (new_rating, old_player) {
                              return {
                                      data: old_player.data,
                                      id: old_player.id,
                                      intId: old_player.intId,
                                      name: old_player.name,
                                      rating: new_rating,
                                      ratingOrdinal: old_player.ratingOrdinal,
                                      paid: old_player.paid,
                                      gender: old_player.gender,
                                      count: old_player.count
                                    };
                            }));
              }));
}

function toStableId$1(param) {
  return [
              toStableId(param[0]),
              toStableId(param[1])
            ].toSorted(Core__String.compare).join("-");
}

function players(param) {
  return [
            param[0],
            param[1]
          ].flatMap(function (x) {
              return x;
            });
}

function mapPlayers(param, fn) {
  return [
          param[0].map(fn),
          param[1].map(fn)
        ];
}

function incrementPlayCounts(match) {
  return mapPlayers(match, (function (player) {
                return {
                        data: player.data,
                        id: player.id,
                        intId: player.intId,
                        name: player.name,
                        rating: player.rating,
                        ratingOrdinal: player.ratingOrdinal,
                        paid: player.paid,
                        gender: player.gender,
                        count: player.count + 1 | 0
                      };
              }));
}

function getWinners(match, score) {
  var team2Score = score[1];
  var team1Score = score[0];
  var winningTeam = team1Score > team2Score ? match[0] : match[1];
  var winningScore = team1Score > team2Score ? team1Score : team2Score;
  return [
          winningTeam.map(function (p) {
                return p.id;
              }),
          winningScore
        ];
}

function getLosers(match, score) {
  var team2Score = score[1];
  var team1Score = score[0];
  var losingTeam = team1Score > team2Score ? match[1] : match[0];
  var losingScore = team1Score > team2Score ? team2Score : team1Score;
  return [
          losingTeam.map(function (p) {
                return p.id;
              }),
          losingScore
        ];
}

function toDb$2(match) {
  return toDb$1(match[0]).concat(toDb$1(match[1]));
}

function loadFromDb(_matchRow, teamsTable, playersTable, matchId) {
  var teams = Core__Array.filterMap(Js_dict.entries(teamsTable), (function (param) {
              var teamRow = param[1];
              var match = Core__Option.map(Js_dict.get(teamRow, "matchId"), (function (v) {
                      return v;
                    }));
              var match$1 = Core__Option.map(Js_dict.get(teamRow, "teamIndex"), (function (v) {
                      return v;
                    }));
              var match$2 = Core__Option.flatMap(Js_dict.get(teamRow, "playerIds"), Js_json.decodeString);
              if (match === undefined) {
                return ;
              }
              if (match$1 === undefined) {
                return ;
              }
              if (match$2 === undefined) {
                return ;
              }
              if (match !== matchId) {
                return ;
              }
              try {
                var playerIds = Core__Array.filterMap(Core__Option.getOr(Js_json.decodeArray(JSON.parse(match$2)), []), Js_json.decodeString);
                var players = Core__Array.filterMap(playerIds, (function (playerId) {
                        return Core__Option.flatMap(Js_dict.get(playersTable, playerId), fromDb);
                      }));
                return [
                        match$1,
                        players
                      ];
              }
              catch (exn){
                return ;
              }
            })).toSorted(function (param, param$1) {
          if (param[0] < param$1[0]) {
            return -1;
          } else {
            return 1;
          }
        }).map(function (param) {
        return param[1];
      });
  if (teams.length !== 2) {
    return ;
  }
  var team1 = teams[0];
  var team2 = teams[1];
  return [
          team1,
          team2
        ];
}

var Match = {
  contains_player: contains_player$1,
  contains_any_players: contains_any_players,
  contains_all_players: contains_all_players,
  contains_more_than_1_players: contains_more_than_1_players,
  rate: rate,
  toStableId: toStableId$1,
  players: players,
  mapPlayers: mapPlayers,
  incrementPlayCounts: incrementPlayCounts,
  getWinners: getWinners,
  getLosers: getLosers,
  toDb: toDb$2,
  loadFromDb: loadFromDb
};

function submit(param, activitySlug, submitMatch) {
  var score = param[1];
  if (score !== undefined) {
    return submitMatch(param[0], [
                score[0],
                score[1]
              ], activitySlug);
  } else {
    return Promise.resolve();
  }
}

function toStableId$2(param) {
  return toStableId$1(param[0]);
}

function getWinners$1(param) {
  var match = param[0];
  return Core__Option.map(param[1], (function (s) {
                return getWinners(match, s);
              }));
}

function getLosers$1(param) {
  var match = param[0];
  return Core__Option.map(param[1], (function (s) {
                return getLosers(match, s);
              }));
}

function rate$1(param) {
  var match = param[0];
  return Core__Option.map(param[1], (function (s) {
                var team2 = match[1];
                var team1 = match[0];
                var match$1 = s[0] > s[1] ? [
                    team1,
                    team2
                  ] : [
                    team2,
                    team1
                  ];
                return rate([
                            match$1[0],
                            match$1[1]
                          ]);
              }));
}

var CompletedMatch = {
  submit: submit,
  toStableId: toStableId$2,
  getWinners: getWinners$1,
  getLosers: getLosers$1,
  rate: rate$1
};

function getLastPlayedPlayers(matches, restCount, availablePlayers) {
  var playersCount = availablePlayers - restCount | 0;
  var teams = matches.toReversed().flatMap(function (param) {
        var match = param[0];
        return [
                match[0],
                match[1]
              ];
      });
  return teams.flatMap(function (p) {
                return p;
              }).slice(0, playersCount);
}

function getLastRoundMatches(matches, restCount, availablePlayers, playersPerMatch) {
  var lastPlayedCount = getLastPlayedPlayers(matches, restCount, availablePlayers).length;
  var matchesPlayed = Caml_int32.div(lastPlayedCount, playersPerMatch);
  return matches.toReversed().slice(0, matchesPlayed);
}

function getNumberOfRounds(matches, restCount, availablePlayers, playersPerMatch) {
  var lastPlayedCount = getLastPlayedPlayers(matches, restCount, availablePlayers).length;
  var matchesLastPlayed = Caml_int32.div(lastPlayedCount, playersPerMatch);
  if (matchesLastPlayed !== 0) {
    return Caml_int32.div(matches.length, matchesLastPlayed);
  } else {
    return 0;
  }
}

function saveMatches(t, namespace) {
  var t$1 = t.map(function (param) {
        var match = param[0];
        return [
                [
                  match[0].map(function (p) {
                        return p.id;
                      }),
                  match[1].map(function (p) {
                        return p.id;
                      })
                ],
                param[1]
              ];
      });
  localStorage.setItem(namespace + "-matchesState", LzString.compress(Core__Option.getOr(JSON.stringify(t$1), "")));
}

function loadMatches(namespace, players) {
  var players$1 = Core__Array.reduce(players, {}, (function (acc, player) {
          acc[player.id] = player;
          return acc;
        }));
  var state = localStorage.getItem(namespace + "-matchesState");
  var tmp;
  if (state !== null) {
    var decompressed = LzString.decompress(state);
    tmp = decompressed === "" ? [] : JSON.parse(decompressed);
  } else {
    tmp = [];
  }
  return Core__Array.filterMap(tmp.map(function (param) {
                  var match = param[0];
                  var score = Caml_option.nullable_to_opt(param[1]);
                  return [
                          [
                            Core__Array.reduce(match[0].map(function (p) {
                                      return Js_dict.get(players$1, p);
                                    }), [], (function (acc, player) {
                                    return Core__Option.flatMap(acc, (function (acc) {
                                                  if (player !== undefined) {
                                                    return acc.concat([player]);
                                                  }
                                                  
                                                }));
                                  })),
                            Core__Array.reduce(match[1].map(function (p) {
                                      return Js_dict.get(players$1, p);
                                    }), [], (function (acc, player) {
                                    return Core__Option.flatMap(acc, (function (acc) {
                                                  if (player !== undefined) {
                                                    return acc.concat([player]);
                                                  }
                                                  
                                                }));
                                  }))
                          ],
                          score
                        ];
                }), (function (param) {
                var match = param[0];
                var team2 = match[1];
                var team1 = match[0];
                if (team1 !== undefined && team2 !== undefined) {
                  return [
                          [
                            team1,
                            team2
                          ],
                          param[1]
                        ];
                }
                
              }));
}

function scored_matches(t) {
  return Core__Array.filterMap(t, (function (param) {
                var score = param[1];
                if (score !== undefined) {
                  return [
                          param[0],
                          score
                        ];
                }
                
              }));
}

var CompletedMatches = {
  getLastPlayedPlayers: getLastPlayedPlayers,
  getLastRoundMatches: getLastRoundMatches,
  getNumberOfRounds: getNumberOfRounds,
  saveMatches: saveMatches,
  loadMatches: loadMatches,
  scored_matches: scored_matches
};

function fromTeam(team) {
  if (team.length !== 2) {
    return {
            TAG: "Error",
            _0: "TwoPlayersRequired"
          };
  }
  var p1 = team[0];
  var p2 = team[1];
  return {
          TAG: "Ok",
          _0: [
            p1,
            p2
          ]
        };
}

var DoublesTeam = {
  fromTeam: fromTeam
};

function fromMatch(param) {
  var t1 = fromTeam(param[0]);
  var t2 = fromTeam(param[1]);
  if (t1.TAG === "Ok") {
    if (t2.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: [
                t1._0,
                t2._0
              ]
            };
    } else {
      return {
              TAG: "Error",
              _0: t2._0
            };
    }
  } else {
    return {
            TAG: "Error",
            _0: t1._0
          };
  }
}

var DoublesMatch = {
  fromMatch: fromMatch
};

function toDb$3(entity) {
  var row = {};
  row["matchId"] = entity.id;
  row["type"] = "completedMatchEntity";
  var match = entity.match;
  var team1Ids = match[0].map(function (p) {
        return p.id;
      });
  var team2Ids = match[1].map(function (p) {
        return p.id;
      });
  row["team1PlayerIds"] = team1Ids;
  row["team2PlayerIds"] = team2Ids;
  var match$1 = entity.score;
  if (match$1 !== undefined) {
    row["hasScore"] = true;
    row["team1Score"] = match$1[0];
    row["team2Score"] = match$1[1];
  } else {
    row["hasScore"] = false;
  }
  row["createdAt"] = entity.createdAt.getTime();
  return row;
}

function loadFromDb$1(row, playersTable) {
  var match = Core__Option.flatMap(Js_dict.get(row, "matchId"), Js_json.decodeString);
  var match$1 = Core__Option.flatMap(Js_dict.get(row, "team1PlayerIds"), Js_json.decodeArray);
  var match$2 = Core__Option.flatMap(Js_dict.get(row, "team2PlayerIds"), Js_json.decodeArray);
  var match$3 = Core__Option.flatMap(Js_dict.get(row, "createdAt"), Js_json.decodeNumber);
  if (match === undefined) {
    return ;
  }
  if (match$1 === undefined) {
    return ;
  }
  if (match$2 === undefined) {
    return ;
  }
  var team1PlayerIds = Core__Array.filterMap(match$1, Js_json.decodeString);
  var team2PlayerIds = Core__Array.filterMap(match$2, Js_json.decodeString);
  var team1 = Core__Array.filterMap(team1PlayerIds, (function (playerId) {
          return Core__Option.flatMap(Js_dict.get(playersTable, playerId), fromDb);
        }));
  var team2 = Core__Array.filterMap(team2PlayerIds, (function (playerId) {
          return Core__Option.flatMap(Js_dict.get(playersTable, playerId), fromDb);
        }));
  var match$4 = Core__Option.flatMap(Js_dict.get(row, "hasScore"), Js_json.decodeBoolean);
  var score;
  if (match$4 !== undefined && match$4) {
    var match$5 = Core__Option.flatMap(Js_dict.get(row, "team1Score"), Js_json.decodeNumber);
    var match$6 = Core__Option.flatMap(Js_dict.get(row, "team2Score"), Js_json.decodeNumber);
    score = match$5 !== undefined && match$6 !== undefined ? [
        match$5,
        match$6
      ] : undefined;
  } else {
    score = undefined;
  }
  return {
          id: match,
          match: [
            team1,
            team2
          ],
          score: score,
          createdAt: Core__Option.getOr(Core__Option.map(match$3, (function (ts) {
                      return new Date(ts);
                    })), new Date())
        };
}

var CompletedMatchEntity = {
  toDb: toDb$3,
  loadFromDb: loadFromDb$1
};

function toJson$1(adj) {
  var dict = {};
  dict["playerId"] = adj.playerId;
  dict["differential"] = adj.differential;
  dict["appliedAtRound"] = adj.appliedAtRound;
  dict["timestamp"] = adj.timestamp;
  return dict;
}

function fromJson$1(json) {
  return Core__Option.flatMap(Js_json.decodeObject(json), (function (dict) {
                var match = Core__Option.flatMap(Js_dict.get(dict, "playerId"), Js_json.decodeString);
                var match$1 = Core__Option.flatMap(Js_dict.get(dict, "differential"), Js_json.decodeNumber);
                var match$2 = Core__Option.flatMap(Js_dict.get(dict, "appliedAtRound"), Js_json.decodeNumber);
                var match$3 = Core__Option.flatMap(Js_dict.get(dict, "timestamp"), Js_json.decodeNumber);
                if (match !== undefined && match$1 !== undefined && match$2 !== undefined && match$3 !== undefined) {
                  return {
                          playerId: match,
                          differential: match$1,
                          appliedAtRound: match$2 | 0,
                          timestamp: match$3
                        };
                }
                
              }));
}

var RatingAdjustment = {
  toJson: toJson$1,
  fromJson: fromJson$1
};

function fromRoundsAndAdjustments(rounds, adjustments) {
  var adjustmentsByRound = new Map();
  adjustments.forEach(function (adj) {
        var existing = Core__Option.getOr(adjustmentsByRound.get(adj.appliedAtRound), []);
        adjustmentsByRound.set(adj.appliedAtRound, existing.concat([adj]));
      });
  var timeline = [];
  var seedAdjustments = adjustmentsByRound.get(-1);
  if (seedAdjustments !== undefined) {
    timeline.push({
          TAG: "Adjustment",
          _0: seedAdjustments
        });
  }
  rounds.forEach(function (roundMatches, roundIndex) {
        var roundAdjustments = adjustmentsByRound.get(roundIndex);
        if (roundAdjustments !== undefined) {
          timeline.push({
                TAG: "Adjustment",
                _0: roundAdjustments
              });
        }
        timeline.push({
              TAG: "Round",
              _0: roundMatches
            });
      });
  adjustments.filter(function (adj) {
          return adj.appliedAtRound >= rounds.length;
        }).forEach(function (adj) {
        var futureAdjustments = adjustmentsByRound.get(adj.appliedAtRound);
        if (futureAdjustments !== undefined) {
          timeline.push({
                TAG: "Adjustment",
                _0: futureAdjustments
              });
          adjustmentsByRound.delete(adj.appliedAtRound);
          return ;
        }
        
      });
  return timeline;
}

var TimelineEvent = {
  fromRoundsAndAdjustments: fromRoundsAndAdjustments
};

var decodeRating = Json_Decode$JsonCombinators.object(function (field) {
      var mu = field.required("mu", Json_Decode$JsonCombinators.$$float);
      var sigma = field.required("sigma", Json_Decode$JsonCombinators.$$float);
      return make(mu, sigma);
    });

var decodeGender = Json_Decode$JsonCombinators.map(Json_Decode$JsonCombinators.$$int, fromInt);

var decodePlayer$1 = Json_Decode$JsonCombinators.object(function (field) {
      var id = field.required("id", Json_Decode$JsonCombinators.string);
      var intId = field.required("intId", Json_Decode$JsonCombinators.$$int);
      var name = field.required("name", Json_Decode$JsonCombinators.string);
      var rating = field.required("rating", decodeRating);
      var ratingOrdinal = field.required("ratingOrdinal", Json_Decode$JsonCombinators.$$float);
      var paid = field.required("paid", Json_Decode$JsonCombinators.bool);
      var gender = field.required("gender", decodeGender);
      var count = Core__Option.getOr(field.optional("count", Json_Decode$JsonCombinators.$$int), 0);
      return {
              data: undefined,
              id: id,
              intId: intId,
              name: name,
              rating: rating,
              ratingOrdinal: ratingOrdinal,
              paid: paid,
              gender: gender,
              count: count
            };
    });

var decodeEventManagerPlayer = Json_Decode$JsonCombinators.object(function (field) {
      var id = field.required("id", Json_Decode$JsonCombinators.string);
      var intId = field.required("intId", Json_Decode$JsonCombinators.$$int);
      var name = field.required("name", Json_Decode$JsonCombinators.string);
      var rating = field.required("rating", decodeRating);
      var ratingOrdinal = field.required("ratingOrdinal", Json_Decode$JsonCombinators.$$float);
      var paid = field.required("paid", Json_Decode$JsonCombinators.bool);
      var gender = field.required("gender", decodeGender);
      var count = Core__Option.getOr(field.optional("count", Json_Decode$JsonCombinators.$$int), 0);
      return {
              data: undefined,
              id: id,
              intId: intId,
              name: name,
              rating: rating,
              ratingOrdinal: ratingOrdinal,
              paid: paid,
              gender: gender,
              count: count
            };
    });

function parsePlayersFromStorage(jsonString) {
  try {
    var json = JSON.parse(jsonString);
    var resultDict = {};
    var playersDecoder = Json_Decode$JsonCombinators.dict(decodePlayer$1);
    var playersDict = Json_Decode$JsonCombinators.decode(json, playersDecoder);
    if (playersDict.TAG === "Ok") {
      Js_dict.entries(playersDict._0).forEach(function (param) {
            resultDict[param[0]] = param[1];
          });
    } else {
      console.log(playersDict._0);
      console.log("Failed to decode all players at once, trying individual decoding");
      var obj = Js_json.classify(json);
      if (typeof obj !== "object" || obj.TAG !== "JSONObject") {
        console.error("Players storage is not a JSON object");
      } else {
        Js_dict.entries(obj._0).forEach(function (param) {
              var key = param[0];
              var player = Json_Decode$JsonCombinators.decode(param[1], decodePlayer$1);
              if (player.TAG === "Ok") {
                resultDict[key] = player._0;
                return ;
              }
              console.log("Failed to decode player with key: " + key);
            });
      }
    }
    return resultDict;
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === Js_exn.$$Error) {
      console.error("Failed to parse players JSON: ", e._1);
      return {};
    } else {
      console.error("Unknown error occurred while parsing players JSON");
      return {};
    }
  }
}

var PlayerDecoder = {
  decodeRating: decodeRating,
  decodeGender: decodeGender,
  decodePlayer: decodePlayer$1,
  decodeEventManagerPlayer: decodeEventManagerPlayer,
  parsePlayersFromStorage: parsePlayersFromStorage
};

function sortByRatingDesc(t) {
  return t.toSorted(function (a, b) {
              var userA = a.rating.mu;
              var userB = b.rating.mu;
              if (userA < userB) {
                return 1;
              } else {
                return -1;
              }
            });
}

function sortByPlayCountAsc(t, session) {
  return t.toSorted(function (a, b) {
              if (Session.get(session, a.id).count < Session.get(session, b.id).count) {
                return -1;
              } else {
                return 1;
              }
            });
}

function sortByPlayCountDesc(t, session) {
  return t.toSorted(function (a, b) {
              if (Session.get(session, a.id).count < Session.get(session, b.id).count) {
                return 1;
              } else {
                return -1;
              }
            });
}

function sortByOrdinalDesc(t) {
  return t.toSorted(function (a, b) {
              if (a.ratingOrdinal < b.ratingOrdinal) {
                return 1;
              } else {
                return -1;
              }
            });
}

function filterOut(players, unavailable) {
  return players.filter(function (p) {
              return !unavailable.has(p.id);
            });
}

function mustInclude(players, mustPlayers) {
  return players.filter(function (p) {
              return mustPlayers.has(p.id);
            });
}

function addBreakPlayersFrom(breakPlayers, players, breakCount) {
  return filterOut(players, new Set(breakPlayers.map(function (p) {
                          return p.id;
                        }))).slice(0, breakCount - breakPlayers.length | 0).concat(breakPlayers);
}

function savePlayers(t, namespace) {
  var t$1 = t.map(function (p) {
        return {
                data: undefined,
                id: p.id,
                intId: p.intId,
                name: p.name,
                rating: p.rating,
                ratingOrdinal: p.ratingOrdinal,
                paid: p.paid,
                gender: p.gender,
                count: p.count
              };
      });
  var t$2 = Core__Array.reduce(t$1, {}, (function (acc, player) {
          acc[player.id] = player;
          return acc;
        }));
  localStorage.setItem(namespace + "-playersState", Core__Option.getOr(JSON.stringify(t$2), ""));
}

function loadPlayers(players, namespace) {
  var state = localStorage.getItem(namespace + "-playersState");
  var storage = state !== null ? parsePlayersFromStorage(state) : ({});
  var maxPlayerIntId = Core__Array.reduce(players, 0, (function (max, p) {
          if (p.intId > max) {
            return p.intId;
          } else {
            return max;
          }
        }));
  var guests = Object.keys(storage).filter(function (id) {
          return id.startsWith("guest-");
        }).map(function (id, index) {
        var player = Js_dict.get(storage, id);
        if (player !== undefined) {
          return {
                  data: undefined,
                  id: player.id,
                  intId: player.intId,
                  name: player.name,
                  rating: player.rating,
                  ratingOrdinal: player.ratingOrdinal,
                  paid: player.paid,
                  gender: player.gender,
                  count: player.count
                };
        } else {
          return makeDefaultRatingPlayer(id, "Male", (maxPlayerIntId + index | 0) + 1 | 0);
        }
      });
  return players.map(function (p) {
                return Core__Option.getOr(Core__Option.map(Js_dict.get(storage, p.id), (function (store) {
                                  return {
                                          data: p.data,
                                          id: store.id,
                                          intId: store.intId,
                                          name: store.name,
                                          rating: store.rating,
                                          ratingOrdinal: store.ratingOrdinal,
                                          paid: store.paid,
                                          gender: store.gender,
                                          count: store.count
                                        };
                                })), p);
              }).concat(guests);
}

function calculateMeanRating(group) {
  if (group.length === 0) {
    return 0.0;
  }
  var sumOfMus = Core__Array.reduce(group, 0.0, (function (acc, p) {
          return acc + p.rating.mu;
        }));
  return sumOfMus / group.length;
}

function clusterByRating(rankedPlayers_t, maxDiff) {
  var resultingClusters = [];
  var currentGroup = {
    contents: []
  };
  rankedPlayers_t.forEach(function (player) {
        var testGroup = currentGroup.contents.concat([player]);
        var testGroupMean = calculateMeanRating(testGroup);
        var conditionMet = testGroup.every(function (p_in_test_group) {
              return Math.abs(testGroupMean - p_in_test_group.rating.mu) < maxDiff;
            });
        if (conditionMet) {
          currentGroup.contents = testGroup;
        } else {
          if (currentGroup.contents.length > 0) {
            resultingClusters.push(currentGroup.contents);
          }
          currentGroup.contents = [player];
        }
      });
  if (currentGroup.contents.length > 0) {
    resultingClusters.push(currentGroup.contents);
  }
  return resultingClusters;
}

function toKMeansData(players) {
  return Util.NonEmptyArray.fromArray(players.map(function (player) {
                  return [player.rating.mu];
                }));
}

function findOptimalClustersRecursive(kMeansData, _currentKValue) {
  while(true) {
    var currentKValue = _currentKValue;
    if (currentKValue < 1) {
      console.warn("K-Means recursion: currentKValue fell below 1. Defaulting to k=1.");
      return KMeansClusteringJs.runKMeansWithOptimalInertia({
                  data: kMeansData,
                  k: 1,
                  numRuns: 100,
                  maxIterations: 1000,
                  tolerance: 1e-6
                });
    }
    var currentRunOutput = KMeansClusteringJs.runKMeansWithOptimalInertia({
          data: kMeansData,
          k: currentKValue,
          numRuns: 100,
          maxIterations: 1000,
          tolerance: 1e-6
        });
    var currentlySortedClusters = Util.NonEmptyArray.toArray(KMeans.SortedClusters.make(currentRunOutput));
    if (currentlySortedClusters.length > 0) {
      var firstCluster = currentlySortedClusters[0];
      var firstClusterPlayerCount = firstCluster.points.length;
      console.log("Recursive k-means: k=" + currentKValue.toString() + ", first cluster size=" + firstClusterPlayerCount.toString());
      if (firstClusterPlayerCount >= 4) {
        return currentlySortedClusters;
      }
      if (currentKValue === 1) {
        return currentlySortedClusters;
      }
      if (currentKValue >= 3) {
        var merged = [KMeans.ClusterResult.concat(currentlySortedClusters[0], currentlySortedClusters[1])].concat(currentlySortedClusters.slice(2, currentlySortedClusters.length));
        var firstCluster$1 = merged[0];
        if (firstCluster$1.points.length > 3) {
          return merged;
        }
        console.warn("K-Means recursion: Merged cluster size is <= 3 for k=" + currentKValue.toString() + ". Trying k-1.");
        _currentKValue = currentKValue - 1 | 0;
        continue ;
      }
      _currentKValue = currentKValue - 1 | 0;
      continue ;
    }
    console.warn("K-Means recursion: Library returned no clusters for k=" + currentKValue.toString() + ". Trying k-1 if possible.");
    if (currentKValue <= 1) {
      return Util.NonEmptyArray.toArray(KMeans.SortedClusters.make(KMeansClusteringJs.runKMeansWithOptimalInertia({
                          data: kMeansData,
                          k: 1,
                          numRuns: 100,
                          maxIterations: 1000,
                          tolerance: 1e-6
                        })));
    }
    _currentKValue = currentKValue - 1 | 0;
    continue ;
  };
}

function findPlayerClusters(t, k) {
  return Core__Option.mapOr(toKMeansData(t), [], (function (arr) {
                return findOptimalClustersRecursive(arr, Core__Option.getOr(Util.NonZeroInt.toOption(k), 1));
              }));
}

var Players = {
  sortByRatingDesc: sortByRatingDesc,
  sortByPlayCountAsc: sortByPlayCountAsc,
  sortByPlayCountDesc: sortByPlayCountDesc,
  sortByOrdinalDesc: sortByOrdinalDesc,
  filterOut: filterOut,
  mustInclude: mustInclude,
  addBreakPlayersFrom: addBreakPlayersFrom,
  savePlayers: savePlayers,
  loadPlayers: loadPlayers,
  calculateMeanRating: calculateMeanRating,
  clusterByRating: clusterByRating,
  toKMeansData: toKMeansData,
  findOptimalClustersRecursive: findOptimalClustersRecursive,
  findPlayerClusters: findPlayerClusters
};

function make$2(t) {
  if (t.length >= 4) {
    return t;
  }
  
}

function toPlayers(t) {
  return t;
}

var DoublesSet = {
  make: make$2,
  toPlayers: toPlayers
};

function make$3(t) {
  return t.toSorted(function (a, b) {
              var userA = a.rating.mu;
              var userB = b.rating.mu;
              if (userA < userB) {
                return 1;
              } else {
                return -1;
              }
            });
}

function min_rating(playersArray, minRatingValue) {
  return playersArray.filter(function (player) {
              return player.rating.mu >= minRatingValue;
            });
}

function to_players(t) {
  return t;
}

function splitByGroups(players, _groups) {
  var groups = Js_math.ceil_int(players.length / 6);
  var clusters = findPlayerClusters(players, Util.NonZeroInt.make(groups));
  return KMeans.SortedClusters.make(clusters);
}

function findTopGroup(players, groups) {
  var sortedClusters = splitByGroups(players, groups);
  var minRating = KMeans.SortedClusters.getMin(sortedClusters);
  return min_rating(players, minRating);
}

function filter(prim0, prim1) {
  return prim0.filter(prim1);
}

var RankedPlayers = {
  make: make$3,
  min_rating: min_rating,
  to_players: to_players,
  splitByGroups: splitByGroups,
  findTopGroup: findTopGroup,
  filter: filter
};

function array_get_n_from(arr, from, n) {
  var n$1 = arr.length > 3 && arr.length < n ? arr.length : n;
  if (from >= (arr.length - (n$1 - 1 | 0) | 0)) {
    return ;
  }
  var arr$1 = arr.slice(from, from + n$1 | 0);
  if (n$1 === arr$1.length) {
    return arr$1;
  }
  
}

function array_split_by_n(arr, n) {
  var _from = 0;
  var _acc = [];
  while(true) {
    var acc = _acc;
    var from = _from;
    var next = array_get_n_from(arr, from, n);
    if (next === undefined) {
      return acc;
    }
    _acc = acc.concat([next]);
    _from = from + 1 | 0;
    continue ;
  };
}

function array_combos(arr) {
  return arr.flatMap(function (v, i) {
              return arr.slice(i + 1 | 0, arr.length).map(function (v2) {
                          return [
                                  v,
                                  v2
                                ];
                        });
            });
}

function array_combinations_n(arr, n) {
  var helper = function (arr, n, acc) {
    if (n === 0) {
      return [acc];
    }
    if (arr.length === 0) {
      return [];
    }
    var head = arr[0];
    var tail = arr.slice(1, arr.length);
    var withHead = helper(tail, n - 1 | 0, acc.concat([head]));
    var withoutHead = helper(tail, n, acc);
    return withHead.concat(withoutHead);
  };
  return helper(arr, n, []);
}

function combos(arr1, arr2) {
  return arr1.flatMap(function (d) {
              return arr2.map(function (v) {
                          return [
                                  d,
                                  v
                                ];
                        });
            });
}

function match_quality(param) {
  return Rating_predictDraw([
              param[0].map(function (p) {
                    return p.rating;
                  }),
              param[1].map(function (p) {
                    return p.rating;
                  })
            ]);
}

function shuffle(arr) {
  return arr.map(function (value) {
                  return {
                          value: value,
                          sort: Math.random()
                        };
                }).toSorted(function (a, b) {
                return a.sort - b.sort;
              }).map(function (param) {
              return param.value;
            });
}

function tuple2array(param) {
  return [
          param[0],
          param[1]
        ];
}

function team_to_players_set(team) {
  return new Set(team.map(function (p) {
                  return p.id;
                }));
}

function find_all_match_combos(availablePlayers, priorityPlayers, avoidAllPlayers, teamConstraints, requiredPlayers) {
  var teams = array_combos(availablePlayers).map(tuple2array);
  var teamConstraintsSet = new Set(Util.NonEmptyArray.toArray(teamConstraints).map(function (a) {
              return Array.from(a.values());
            }).flatMap(function (x) {
            return x;
          }));
  var implicitTeam = new Set(availablePlayers.filter(function (p) {
              return !teamConstraintsSet.has(p.id);
            }).map(function (p) {
            return p.id;
          }));
  var quads = array_combinations_n(availablePlayers, 4);
  var new_matches = quads.flatMap(function (quad) {
        var p1 = quad[0];
        var p2 = quad[1];
        var p3 = quad[2];
        var p4 = quad[3];
        return [
                [
                  [
                    p1,
                    p2
                  ],
                  [
                    p3,
                    p4
                  ]
                ],
                [
                  [
                    p1,
                    p3
                  ],
                  [
                    p2,
                    p4
                  ]
                ],
                [
                  [
                    p1,
                    p4
                  ],
                  [
                    p2,
                    p3
                  ]
                ]
              ];
      });
  teams.map(function (team_players_array) {
        return toSet(team_players_array);
      });
  var matches = new_matches.map(function (match) {
        var quality = match_quality(match);
        return [
                match,
                quality
              ];
      });
  var results = priorityPlayers.length === 0 ? matches : matches.filter(function (param) {
          return contains_any_players(param[0], priorityPlayers);
        });
  var results$1 = Core__Array.reduce(avoidAllPlayers, results, (function (matches, antiTeam) {
          if (antiTeam.length < 2) {
            return matches;
          } else {
            return Belt_Array.concatMany([matches.filter(function (param) {
                              return !contains_more_than_1_players(param[0], antiTeam);
                            })]);
          }
        }));
  var results$2;
  if (requiredPlayers !== undefined) {
    var reqPlayerIds = Caml_option.valFromOption(requiredPlayers);
    if (reqPlayerIds.size > 0) {
      var requiredPlayersArray = availablePlayers.filter(function (p) {
            return reqPlayerIds.has(p.id);
          });
      results$2 = requiredPlayersArray.length === reqPlayerIds.size ? results$1.filter(function (param) {
              return contains_all_players(param[0], requiredPlayersArray);
            }) : [];
    } else {
      results$2 = results$1;
    }
  } else {
    results$2 = results$1;
  }
  var teamConstraintsAsArray = Util.NonEmptyArray.toArray(teamConstraints);
  var finalTeamConstraintsList = teamConstraintsAsArray.concat([implicitTeam]);
  return results$2.filter(function (param) {
              var match = param[0];
              var team1Set = toSet(match[0]);
              var team2Set = toSet(match[1]);
              var team1SatisfiesConstraint = finalTeamConstraintsList.findIndex(function (constr) {
                    return containsAllOf(constr, team1Set);
                  }) > -1;
              var team2SatisfiesConstraint = finalTeamConstraintsList.findIndex(function (constr) {
                    return containsAllOf(constr, team2Set);
                  }) > -1;
              if (team1SatisfiesConstraint) {
                return team2SatisfiesConstraint;
              } else {
                return false;
              }
            });
}

function find_skip(n) {
  if (n === 0) {
    return 1;
  } else {
    return (find_skip(n - 1 | 0) + n | 0) + 1 | 0;
  }
}

function pick_every_n_from_array(arr, n, offset) {
  return arr.filter(function (param, i) {
              return Caml_int32.mod_(i - offset | 0, n) === 0;
            });
}

function uniform_shuffle_array(arr, n, offset) {
  if (n === offset) {
    return [];
  }
  var picks = pick_every_n_from_array(arr, n, offset);
  return picks.concat(uniform_shuffle_array(arr, n, offset + 1 | 0));
}

function strategy_by_competitive(players, _consumedPlayers, priorityPlayers, avoidAllPlayers, teams, requiredPlayers) {
  return Core__Array.reduce(array_split_by_n(sortByRatingDesc(players), 5), [], (function (acc, playerSet) {
                  var matches = find_all_match_combos(playerSet, priorityPlayers, avoidAllPlayers, teams, requiredPlayers);
                  return acc.concat(matches);
                })).toSorted(function (a, b) {
              if (a[1] < b[1]) {
                return 1;
              } else {
                return -1;
              }
            });
}

function strategy_by_competitive_plus(players, _consumedPlayers, _priorityPlayers, avoidAllPlayers, teams, requiredPlayers, courts, genderMixed) {
  var sorted = make$3(players);
  var players$1;
  if (genderMixed) {
    var malePlayers = findTopGroup(sorted.filter(function (p) {
              return p.gender === "Male";
            }), courts);
    var femalePlayers = findTopGroup(sorted.filter(function (p) {
              return p.gender === "Female";
            }), courts);
    players$1 = malePlayers.concat(femalePlayers);
  } else {
    players$1 = findTopGroup(sorted, courts);
  }
  return Core__Option.getOr(Core__Option.map(make$2(players$1), (function (playerSet) {
                    var matches = Core__Option.getOr(Core__Option.map(playerSet.at(0), (function (topPlayer) {
                                return find_all_match_combos(playerSet, [], avoidAllPlayers, teams, requiredPlayers).filter(function (param) {
                                              return contains_player$1(param[0], topPlayer);
                                            }).toSorted(function (a, b) {
                                            if (a[1] < b[1]) {
                                              return 1;
                                            } else {
                                              return -1;
                                            }
                                          });
                              })), []);
                    if (genderMixed) {
                      return matches.filter(function (param) {
                                  var match = param[0];
                                  var team1HasFemale = match[0].some(function (p) {
                                        return p.gender === "Female";
                                      });
                                  var team2HasFemale = match[1].some(function (p) {
                                        return p.gender === "Female";
                                      });
                                  if (team1HasFemale) {
                                    return team2HasFemale;
                                  } else {
                                    return false;
                                  }
                                });
                    } else {
                      return matches;
                    }
                  })), []);
}

function strategy_by_mixed(availablePlayers, priorityPlayers, avoidAllPlayers, teams, requiredPlayers, genderMixed) {
  var matches = find_all_match_combos(availablePlayers, priorityPlayers, avoidAllPlayers, teams, requiredPlayers);
  var matches$1 = genderMixed ? matches.filter(function (param) {
          var match = param[0];
          var team1HasFemale = match[0].some(function (p) {
                return p.gender === "Female";
              });
          var team2HasFemale = match[1].some(function (p) {
                return p.gender === "Female";
              });
          if (team1HasFemale) {
            return team2HasFemale;
          } else {
            return false;
          }
        }) : matches;
  return matches$1.toSorted(function (a, b) {
              if (a[1] < b[1]) {
                return 1;
              } else {
                return -1;
              }
            });
}

function strategy_by_round_robin(availablePlayers, priorityPlayers, avoidAllPlayers, teams, requiredPlayers) {
  var count = Math.max(4, availablePlayers.length);
  var skip = find_skip(count - 4 | 0);
  var matches = find_all_match_combos(availablePlayers, priorityPlayers, avoidAllPlayers, teams, requiredPlayers);
  return uniform_shuffle_array(matches, skip, 0);
}

function strategy_by_random(availablePlayers, priorityPlayers, avoidAllPlayers, teams, requiredPlayers) {
  var matches = find_all_match_combos(availablePlayers, priorityPlayers, avoidAllPlayers, teams, requiredPlayers);
  return shuffle(matches);
}

function strategy_by_dupr(availablePlayers, priorityPlayers, avoidAllPlayers, requiredPlayers) {
  var teams = Util.NonEmptyArray.fromArray(array_split_by_n(sortByRatingDesc(availablePlayers), 3).map(function (__x) {
              return __x.map(function (p) {
                          return p.id;
                        });
            }).map(function (prim) {
            return new Set(prim);
          }));
  var matches = find_all_match_combos(availablePlayers, priorityPlayers, avoidAllPlayers, teams, requiredPlayers);
  return matches.toSorted(function (a, b) {
              if (a[1] < b[1]) {
                return 1;
              } else {
                return -1;
              }
            });
}

function recommendMatch(matches, seenTeams, seenMatches, lastRoundSeenTeams, lastRoundSeenMatches, teamConstraints, strategy, teamCountDict) {
  Util.NonEmptyArray.toArray(teamConstraints).map(function (constr) {
          return toStableId(constr);
        }).map(function (teamId) {
        seenTeams.delete(teamId);
        lastRoundSeenTeams.delete(teamId);
      });
  var filterLRSM = function (param) {
    return !lastRoundSeenMatches.has(toStableId$1(param[0]));
  };
  var filterLRST = function (param) {
    var match = param[0];
    return !(lastRoundSeenTeams.has(toStableId(match[0])) || lastRoundSeenTeams.has(toStableId(match[1])));
  };
  var filterSM = function (param) {
    return !seenMatches.has(toStableId$1(param[0]));
  };
  var filterST = function (param) {
    var match = param[0];
    return !(seenTeams.has(toStableId(match[0])) || seenTeams.has(toStableId(match[1])));
  };
  var topQualityMatch = matches.at(0);
  var qualityThreshold = topQualityMatch !== undefined ? topQualityMatch[1] * 0.8 : 0.39;
  var qualityFilter = function (param) {
    return param[1] >= qualityThreshold;
  };
  var avoidanceFilters = [
    filterLRSM,
    filterSM,
    filterLRST,
    filterST
  ];
  var applyFilters = function (currentMatches, filtersToApply) {
    return Core__Array.reduce(filtersToApply, currentMatches, (function (acc, filterFn) {
                  return acc.filter(filterFn);
                }));
  };
  var findResult = function (_currentAvoidanceFilters) {
    while(true) {
      var currentAvoidanceFilters = _currentAvoidanceFilters;
      var filteredByAvoidance = applyFilters(matches, currentAvoidanceFilters);
      var finalFiltered = strategy === "Random" ? filteredByAvoidance : filteredByAvoidance.filter(qualityFilter);
      if (finalFiltered.length > 0) {
        return finalFiltered;
      }
      var fewerFilters = currentAvoidanceFilters.slice(0, currentAvoidanceFilters.length - 1 | 0);
      if (fewerFilters.length === currentAvoidanceFilters.length) {
        return matches.filter(qualityFilter);
      }
      if (fewerFilters.length === 0) {
        return matches.filter(qualityFilter);
      }
      _currentAvoidanceFilters = fewerFilters;
      continue ;
    };
  };
  if (strategy === "Random") {
    var sortedByScore = matches.toSorted(function (param, param$1) {
          var matchB = param$1[0];
          var matchA = param[0];
          var scoreA = getMatchScore(teamCountDict, toStableId(matchA[0]), toStableId(matchA[1]));
          var scoreB = getMatchScore(teamCountDict, toStableId(matchB[0]), toStableId(matchB[1]));
          return scoreA - scoreB | 0;
        });
    var match = sortedByScore.at(0);
    var lowestScore;
    if (match !== undefined) {
      var match$1 = match[0];
      lowestScore = getMatchScore(teamCountDict, toStableId(match$1[0]), toStableId(match$1[1]));
    } else {
      lowestScore = 0;
    }
    var lowestScoreMatches = sortedByScore.filter(function (param) {
          var match = param[0];
          var score = getMatchScore(teamCountDict, toStableId(match[0]), toStableId(match[1]));
          return score === lowestScore;
        });
    var randomFloat = Math.random() * lowestScoreMatches.length;
    var randomIndex = Math.floor(randomFloat) | 0;
    return Core__Option.map(lowestScoreMatches.at(randomIndex), (function (param) {
                  return param[0];
                }));
  }
  if (strategy === "Mixed") {
    var qualityFiltered = matches.filter(qualityFilter);
    var sortedByScore$1 = qualityFiltered.toSorted(function (param, param$1) {
          var matchB = param$1[0];
          var matchA = param[0];
          var scoreA = getMatchScore(teamCountDict, toStableId(matchA[0]), toStableId(matchA[1]));
          var scoreB = getMatchScore(teamCountDict, toStableId(matchB[0]), toStableId(matchB[1]));
          return scoreA - scoreB | 0;
        });
    return Core__Option.map(sortedByScore$1.at(0), (function (param) {
                  return param[0];
                }));
  }
  var bestMatches = findResult(avoidanceFilters);
  return Core__Option.map(bestMatches.at(0), (function (param) {
                return param[0];
              }));
}

var RankedMatches = {
  strategy_by_competitive: strategy_by_competitive,
  strategy_by_competitive_plus: strategy_by_competitive_plus,
  strategy_by_mixed: strategy_by_mixed,
  strategy_by_round_robin: strategy_by_round_robin,
  strategy_by_random: strategy_by_random,
  strategy_by_dupr: strategy_by_dupr,
  recommendMatch: recommendMatch
};

function getMatches(players, consumedPlayers, strategy, priorityPlayers, avoidAllPlayers, teamConstraints, requiredPlayers, courts, genderMixed) {
  switch (strategy) {
    case "CompetitivePlus" :
        return strategy_by_competitive_plus(players, consumedPlayers, priorityPlayers, avoidAllPlayers, teamConstraints, requiredPlayers, courts, genderMixed);
    case "Competitive" :
        return strategy_by_competitive(players, consumedPlayers, priorityPlayers, avoidAllPlayers, teamConstraints, requiredPlayers);
    case "Mixed" :
        return strategy_by_mixed(players, priorityPlayers, avoidAllPlayers, teamConstraints, requiredPlayers, genderMixed);
    case "RoundRobin" :
        return strategy_by_round_robin(players, priorityPlayers, avoidAllPlayers, teamConstraints, requiredPlayers);
    case "Random" :
        return strategy_by_random(players, priorityPlayers, avoidAllPlayers, teamConstraints, requiredPlayers);
    case "DUPR" :
        return strategy_by_dupr(players, priorityPlayers, avoidAllPlayers, requiredPlayers);
    
  }
}

function generateMatches(players$1, history, strategy, numMatches, avoidAllPlayersOpt, teamConstraints, courtsOpt, genderMixedOpt, param) {
  var avoidAllPlayers = avoidAllPlayersOpt !== undefined ? avoidAllPlayersOpt : [];
  var courts = courtsOpt !== undefined ? Caml_option.valFromOption(courtsOpt) : Util.NonZeroInt.make(1);
  var genderMixed = genderMixedOpt !== undefined ? genderMixedOpt : false;
  var historyLength = history.length;
  var lastRoundStartIndex = Math.max(0, historyLength - numMatches | 0);
  var teamCountDict = fromHistory(history, (function (completedMatch) {
          var match = completedMatch.match;
          return [
                  toStableId(match[0]),
                  toStableId(match[1])
                ];
        }), numMatches);
  var match = Core__Array.reduceWithIndex(history, [
        new Set(),
        new Set(),
        new Set(),
        new Set()
      ], (function (param, completedMatch, index) {
          var lastMatches = param[3];
          var lastTeams = param[2];
          var allMatches = param[1];
          var allTeams = param[0];
          var match = completedMatch.match;
          var team1Id = toStableId(match[0]);
          var team2Id = toStableId(match[1]);
          var matchId = toStableId$1(completedMatch.match);
          allTeams.add(team1Id);
          allTeams.add(team2Id);
          allMatches.add(matchId);
          if (index >= lastRoundStartIndex) {
            lastTeams.add(team1Id);
            lastTeams.add(team2Id);
            lastMatches.add(matchId);
          }
          return [
                  allTeams,
                  allMatches,
                  lastTeams,
                  lastMatches
                ];
        }));
  var lastRoundSeenMatches = match[3];
  var lastRoundSeenTeams = match[2];
  var seenMatchesFromHistory = match[1];
  var seenTeamsFromHistory = match[0];
  var _consumedPlayers = new Set();
  var _accumulated = [];
  var _remaining = numMatches;
  while(true) {
    var remaining = _remaining;
    var accumulated = _accumulated;
    var consumedPlayers = _consumedPlayers;
    if (remaining <= 0) {
      return accumulated;
    }
    var teamConstraintsNonEmpty = Core__Option.flatMap(teamConstraints, (function (arr) {
            if (arr.length > 0) {
              return arr;
            }
            
          }));
    var availablePlayers = players$1.filter((function(consumedPlayers){
        return function (p) {
          return !consumedPlayers.has(p.id);
        }
        }(consumedPlayers)));
    var teamConstraintsAsTeams = teamConstraintsNonEmpty !== undefined ? Util.NonEmptyArray.fromArray(teamConstraintsNonEmpty.map(function (constraintSet) {
                return players$1.filter(function (p) {
                            return constraintSet.has(p.id);
                          });
              })) : undefined;
    var getCandidateMatches = (function(consumedPlayers,teamConstraintsNonEmpty,availablePlayers){
    return function getCandidateMatches(useMixed) {
      if (teamConstraintsNonEmpty === undefined) {
        return getMatches(availablePlayers, consumedPlayers, strategy, [], avoidAllPlayers, undefined, undefined, courts, useMixed);
      }
      var matchesWithConstraints = getMatches(availablePlayers, consumedPlayers, "Mixed", [], avoidAllPlayers, teamConstraintsNonEmpty, undefined, courts, useMixed);
      if (matchesWithConstraints.length === 0) {
        return getMatches(availablePlayers, consumedPlayers, strategy, [], avoidAllPlayers, undefined, undefined, courts, useMixed);
      } else {
        return matchesWithConstraints;
      }
    }
    }(consumedPlayers,teamConstraintsNonEmpty,availablePlayers));
    var matches = getCandidateMatches(genderMixed);
    var selectedMatch = recommendMatch(matches, seenTeamsFromHistory, seenMatchesFromHistory, lastRoundSeenTeams, lastRoundSeenMatches, teamConstraintsAsTeams, strategy, teamCountDict);
    var selectedMatch$1;
    if (selectedMatch !== undefined || !genderMixed) {
      selectedMatch$1 = selectedMatch;
    } else {
      var matches$1 = getCandidateMatches(false);
      selectedMatch$1 = recommendMatch(matches$1, seenTeamsFromHistory, seenMatchesFromHistory, lastRoundSeenTeams, lastRoundSeenMatches, teamConstraintsAsTeams, strategy, teamCountDict);
    }
    if (selectedMatch$1 === undefined) {
      return accumulated;
    }
    var matchPlayers = players(selectedMatch$1);
    var newConsumedPlayers = Core__Array.reduce(matchPlayers, consumedPlayers, (function (set, player) {
            set.add(player.id);
            return set;
          }));
    var updatedMatch = incrementPlayCounts(selectedMatch$1);
    var randomizedMatch = Math.random() > 0.5 ? [
        updatedMatch[1],
        updatedMatch[0]
      ] : updatedMatch;
    var matchId = "match-" + (accumulated.length + 1 | 0).toString();
    var matchEntity = {
      id: matchId,
      match: randomizedMatch
    };
    _remaining = remaining - 1 | 0;
    _accumulated = accumulated.concat([matchEntity]);
    _consumedPlayers = newConsumedPlayers;
    continue ;
  };
}

function addToQueue(queue, player) {
  var maybePlayer = queue.find(function (p) {
        return Caml_obj.equal(p, player);
      });
  if (maybePlayer !== undefined) {
    return queue;
  } else {
    return queue.concat([player]);
  }
}

function removeFromQueue(queue, player) {
  return queue.filter(function (p) {
              return Caml_obj.notequal(p, player);
            });
}

function toggle(queue, player) {
  var maybePlayer = queue.find(function (p) {
        return Caml_obj.equal(p, player);
      });
  if (maybePlayer !== undefined) {
    return removeFromQueue(queue, player);
  } else {
    return queue.concat([player]);
  }
}

function toSet$1(queue) {
  return new Set(queue);
}

function fromSet(set) {
  return Array.from(set.values());
}

function filter$1(queue, players) {
  return queue.filter(function (p) {
              return !players.has(p);
            });
}

var OrderedQueue = {
  addToQueue: addToQueue,
  removeFromQueue: removeFromQueue,
  toggle: toggle,
  toSet: toSet$1,
  fromSet: fromSet,
  filter: filter$1
};

function addToQueue$1(queue, player) {
  var newSet = new Set();
  queue.forEach(function (id) {
        newSet.add(id);
      });
  newSet.add(player);
  return newSet;
}

function removeFromQueue$1(queue, player) {
  var newSet = new Set();
  queue.forEach(function (id) {
        newSet.add(id);
      });
  newSet.delete(player);
  return newSet;
}

function togglePlayer(queue, player) {
  var newSet = new Set();
  queue.forEach(function (id) {
        newSet.add(id);
      });
  if (queue.has(player)) {
    return removeFromQueue$1(newSet, player);
  } else {
    return addToQueue$1(newSet, player);
  }
}

function toOrdered(queue) {
  return queue.values();
}

function toArray(queue) {
  return Array.from(queue.values());
}

function fromArray(arr) {
  return new Set(arr);
}

function filter$2(queue, players) {
  return queue.difference(players);
}

var UnorderedQueue = {
  addToQueue: addToQueue$1,
  removeFromQueue: removeFromQueue$1,
  togglePlayer: togglePlayer,
  toOrdered: toOrdered,
  toArray: toArray,
  fromArray: fromArray,
  filter: filter$2
};

function fromPlayers(players) {
  return Js_dict.fromArray(players.map(function (p) {
                  return [
                          p.id,
                          p
                        ];
                }));
}

var get = Js_dict.get;

var PlayersCache = {
  fromPlayers: fromPlayers,
  get: get
};

function toDndItems(t) {
  return Js_dict.fromArray(t.map(function (param, i) {
                    return [
                              param[0],
                              param[1]
                            ].map(function (team, j) {
                                return [
                                        i.toString() + "." + j.toString(),
                                        team.map(function (p) {
                                              return i.toString() + "." + j.toString() + ":" + p.id;
                                            })
                                      ];
                              });
                  }).flatMap(function (x) {
                  return x;
                }));
}

function fromDndItems(items, playersCache) {
  return Core__Array.reduce(Js_dict.entries(items).map(function (param) {
                    var players = param[1].map(function (p) {
                          var match = p.split(":");
                          var p$1 = match.length !== 2 ? undefined : match[1];
                          return Core__Option.flatMap(p$1, (function (p) {
                                        return Js_dict.get(playersCache, p);
                                      }));
                        });
                    return Core__Array.filterMap(players, (function (x) {
                                  return x;
                                }));
                  }), [
                [],
                [
                  undefined,
                  undefined
                ]
              ], (function (param, team) {
                  var buildingMatch = param[1];
                  var t1 = buildingMatch[0];
                  var matches = param[0];
                  if (t1 !== undefined) {
                    var t2 = buildingMatch[1];
                    if (t2 !== undefined) {
                      return [
                              matches.concat([[
                                      t1,
                                      t2
                                    ]]),
                              [
                                team,
                                undefined
                              ]
                            ];
                    } else {
                      return [
                              matches.concat([[
                                      t1,
                                      team
                                    ]]),
                              [
                                undefined,
                                undefined
                              ]
                            ];
                    }
                  }
                  var t2$1 = buildingMatch[1];
                  if (t2$1 !== undefined) {
                    return [
                            matches.concat([[
                                    team,
                                    t2$1
                                  ]]),
                            [
                              undefined,
                              undefined
                            ]
                          ];
                  } else {
                    return [
                            matches,
                            [
                              team,
                              undefined
                            ]
                          ];
                  }
                }))[0];
}

var Matches = {
  toDndItems: toDndItems,
  fromDndItems: fromDndItems
};

function guessDupr(ratingMu) {
  return 0.05594 * (ratingMu - 25) + 3.5;
}

function getDeprioritizedPlayers(rounds, players, $$break, strategy) {
  if (rounds.length === 0) {
    return new Set();
  }
  switch (strategy) {
    case "CompetitivePlus" :
    case "Competitive" :
        break;
    default:
      var playersWithRoundsSinceBreak = players.map(function (player) {
            var lastBreakRoundIndex = Core__Array.reduceWithIndex(rounds, undefined, (function (acc, round, roundIndex) {
                    var playedInRound = round.some(function (param) {
                          var m = param.match;
                          return m[0].concat(m[1]).some(function (p) {
                                      return p.id === player.id;
                                    });
                        });
                    if (playedInRound) {
                      return acc;
                    } else {
                      return roundIndex;
                    }
                  }));
            var roundsSinceLastBreak = lastBreakRoundIndex !== undefined ? (rounds.length - lastBreakRoundIndex | 0) - 1 | 0 : rounds.length;
            return [
                    player,
                    roundsSinceLastBreak
                  ];
          });
      return new Set(playersWithRoundsSinceBreak.toSorted(function (a, b) {
                          return b[1] - a[1] | 0;
                        }).slice(0, $$break).map(function (param) {
                      return param[0].id;
                    }));
  }
  var lastRounds = rounds.slice(Math.max(0, rounds.length - $$break | 0), rounds.length);
  var lastPlayed = lastRounds.flatMap(function (round) {
          return round;
        }).flatMap(function (param) {
        var m = param.match;
        return m[0].concat(m[1]);
      });
  var maxCount = Core__Array.reduce(players, 0, (function (acc, next) {
          if (next.count > acc) {
            return next.count;
          } else {
            return acc;
          }
        }));
  var minCount = Core__Array.reduce(players, maxCount, (function (acc, next) {
          if (next.count < acc) {
            return next.count;
          } else {
            return acc;
          }
        }));
  var breakPlayers = addBreakPlayersFrom([], sortByRatingDesc(players.filter(function (p) {
                if (p.count === maxCount) {
                  return p.count !== minCount;
                } else {
                  return false;
                }
              })), $$break);
  if (breakPlayers.length >= $$break) {
    return new Set(breakPlayers.map(function (p) {
                    return p.id;
                  }));
  }
  var breakAndLastPlayed = addBreakPlayersFrom(breakPlayers, sortByRatingDesc(lastPlayed), $$break);
  if (breakAndLastPlayed.length < $$break) {
    return new Set(addBreakPlayersFrom(breakAndLastPlayed, sortByRatingDesc(players), $$break).map(function (p) {
                    return p.id;
                  }));
  } else {
    return new Set(breakAndLastPlayed.map(function (p) {
                    return p.id;
                  }));
  }
}

function processTimelineEvent(players, $$event) {
  if ($$event.TAG === "Round") {
    var match = Core__Array.reduce($$event._0, [
          new Map(),
          new Map()
        ], (function (param, param$1) {
            var m = param$1.match;
            var ratings = param[1];
            var allPlayers = m[0].concat(m[1]);
            var newCounts = Core__Array.reduce(allPlayers, param[0], (function (map, player) {
                    var current = Core__Option.getOr(map.get(player.id), 0);
                    map.set(player.id, current + 1 | 0);
                    return map;
                  }));
            var updatedTeams = rate$1([
                  m,
                  param$1.score
                ]);
            var newRatings = updatedTeams !== undefined ? Core__Array.reduce(updatedTeams.flat(), ratings, (function (map, player) {
                      map.set(player.id, player.rating);
                      return map;
                    })) : ratings;
            return [
                    newCounts,
                    newRatings
                  ];
          }));
    var ratingUpdates = match[1];
    var countIncrements = match[0];
    return players.map(function (player) {
                var countIncrement = Core__Option.getOr(countIncrements.get(player.id), 0);
                var newCount = player.count + countIncrement | 0;
                var rating = ratingUpdates.get(player.id);
                if (rating !== undefined) {
                  return {
                          data: player.data,
                          id: player.id,
                          intId: player.intId,
                          name: player.name,
                          rating: rating,
                          ratingOrdinal: Rating_ordinal(rating),
                          paid: player.paid,
                          gender: player.gender,
                          count: newCount
                        };
                } else {
                  return {
                          data: player.data,
                          id: player.id,
                          intId: player.intId,
                          name: player.name,
                          rating: player.rating,
                          ratingOrdinal: player.ratingOrdinal,
                          paid: player.paid,
                          gender: player.gender,
                          count: newCount
                        };
                }
              });
  }
  var adjustments = $$event._0;
  return players.map(function (player) {
              var totalAdjustment = Core__Array.reduce(adjustments.filter(function (adj) {
                        return adj.playerId === player.id;
                      }), 0.0, (function (sum, adj) {
                      return sum + adj.differential;
                    }));
              if (totalAdjustment === 0.0) {
                return player;
              }
              var currentMu = player.rating.mu;
              var currentSigma = player.rating.sigma;
              var adjustedRating = make(currentMu + totalAdjustment, currentSigma);
              return {
                      data: player.data,
                      id: player.id,
                      intId: player.intId,
                      name: player.name,
                      rating: adjustedRating,
                      ratingOrdinal: Rating_ordinal(adjustedRating),
                      paid: player.paid,
                      gender: player.gender,
                      count: player.count
                    };
            });
}

function updatePlayerState(players, timeline) {
  return Core__Array.reduce(timeline, players, (function (currentPlayers, $$event) {
                return processTimelineEvent(currentPlayers, $$event);
              }));
}

function toPlayerStateWithAdjustments(rounds, players, adjustments) {
  var timeline = fromRoundsAndAdjustments(rounds, adjustments);
  return updatePlayerState(players, timeline);
}

function generateRoundsRec(_roundNumber, _roundsToGenerate, _availablePlayers, completedRounds, strategy, courtCount, teamConstraints, _avoidAllPlayersOpt, _accumulatedRoundsOpt, _genderMixedOpt, startTime, _currentRoundIndexOpt, _param) {
  while(true) {
    var avoidAllPlayersOpt = _avoidAllPlayersOpt;
    var accumulatedRoundsOpt = _accumulatedRoundsOpt;
    var genderMixedOpt = _genderMixedOpt;
    var currentRoundIndexOpt = _currentRoundIndexOpt;
    var availablePlayers = _availablePlayers;
    var roundsToGenerate = _roundsToGenerate;
    var roundNumber = _roundNumber;
    var avoidAllPlayers = avoidAllPlayersOpt !== undefined ? avoidAllPlayersOpt : [];
    var accumulatedRounds = accumulatedRoundsOpt !== undefined ? accumulatedRoundsOpt : [];
    var genderMixed = genderMixedOpt !== undefined ? genderMixedOpt : false;
    var currentRoundIndex = currentRoundIndexOpt !== undefined ? currentRoundIndexOpt : 0;
    if (roundsToGenerate <= 0) {
      return accumulatedRounds;
    }
    if (availablePlayers.length < (courtCount << 2)) {
      return accumulatedRounds;
    }
    console.log("Generating round " + roundNumber.toString());
    var breakCount = courtCount === 0 ? 0 : availablePlayers.length - (courtCount << 2) | 0;
    var allRounds = completedRounds.concat(accumulatedRounds);
    var deprioritizedPlayerIds = getDeprioritizedPlayers(allRounds, availablePlayers, breakCount, strategy);
    var playersForMatches = availablePlayers.filter((function(deprioritizedPlayerIds){
        return function (p) {
          return !deprioritizedPlayerIds.has(p.id);
        }
        }(deprioritizedPlayerIds)));
    var courts = Util.NonZeroInt.make(courtCount);
    var flatHistory = allRounds.flatMap(function (round) {
          return round;
        });
    var matchEntities = generateMatches(playersForMatches, flatHistory, strategy, courtCount, avoidAllPlayers, teamConstraints, Caml_option.some(courts), genderMixed, undefined);
    var baseTime = startTime.getTime();
    var minutesOffset = (currentRoundIndex + 1 | 0) * 10.0 * 60.0 * 1000.0;
    var roundCreatedAt = new Date(baseTime + minutesOffset);
    var roundMatches = matchEntities.map((function(roundCreatedAt){
        return function (matchEntity, _courtNum) {
          return {
                  id: crypto.randomUUID(),
                  match: matchEntity.match,
                  score: undefined,
                  createdAt: roundCreatedAt
                };
        }
        }(roundCreatedAt)));
    var timeline = [{
        TAG: "Round",
        _0: roundMatches
      }];
    var updatedPlayers = updatePlayerState(availablePlayers, timeline);
    _param = undefined;
    _currentRoundIndexOpt = currentRoundIndex + 1 | 0;
    _genderMixedOpt = genderMixed;
    _accumulatedRoundsOpt = accumulatedRounds.concat([roundMatches]);
    _avoidAllPlayersOpt = avoidAllPlayers;
    _availablePlayers = updatedPlayers;
    _roundsToGenerate = roundsToGenerate - 1 | 0;
    _roundNumber = roundNumber + 1 | 0;
    continue ;
  };
}

function generateRounds(startRoundNumberOpt, numberOfRounds, availablePlayers, completedRounds, strategy, courtCount, teamConstraints, avoidAllPlayersOpt, genderMixedOpt, startTime, param) {
  var startRoundNumber = startRoundNumberOpt !== undefined ? startRoundNumberOpt : 1;
  var avoidAllPlayers = avoidAllPlayersOpt !== undefined ? avoidAllPlayersOpt : [];
  var genderMixed = genderMixedOpt !== undefined ? genderMixedOpt : false;
  return generateRoundsRec(startRoundNumber, numberOfRounds, availablePlayers, completedRounds, strategy, courtCount, teamConstraints, avoidAllPlayers, undefined, genderMixed, startTime, 0, undefined);
}

function generateSingleRound(roundIndex, rounds, availablePlayers, strategy, courtCount, teamConstraints, avoidAllPlayersOpt, genderMixedOpt, startTime) {
  var avoidAllPlayers = avoidAllPlayersOpt !== undefined ? avoidAllPlayersOpt : [];
  var genderMixed = genderMixedOpt !== undefined ? genderMixedOpt : false;
  var roundsBeforeThis = roundIndex === 0 ? [] : rounds.filter(function (param, idx) {
          return idx < roundIndex;
        });
  var newRound = generateRounds(roundIndex + 1 | 0, 1, availablePlayers, roundsBeforeThis, strategy, courtCount, teamConstraints, avoidAllPlayers, genderMixed, startTime, undefined);
  return newRound[0];
}

export {
  RatingModel ,
  Gender ,
  makeGuest ,
  Rating ,
  Player ,
  Team ,
  TeamCountDict ,
  TeamSet ,
  Match ,
  CompletedMatch ,
  CompletedMatches ,
  DoublesTeam ,
  DoublesMatch ,
  CompletedMatchEntity ,
  RatingAdjustment ,
  TimelineEvent ,
  PlayerDecoder ,
  Players ,
  DoublesSet ,
  RankedPlayers ,
  array_get_n_from ,
  array_split_by_n ,
  array_combos ,
  array_combinations_n ,
  combos ,
  match_quality ,
  shuffle ,
  tuple2array ,
  team_to_players_set ,
  find_all_match_combos ,
  find_skip ,
  pick_every_n_from_array ,
  uniform_shuffle_array ,
  RankedMatches ,
  getMatches ,
  generateMatches ,
  OrderedQueue ,
  UnorderedQueue ,
  PlayersCache ,
  Matches ,
  guessDupr ,
  getDeprioritizedPlayers ,
  processTimelineEvent ,
  updatePlayerState ,
  toPlayerStateWithAdjustments ,
  generateRoundsRec ,
  generateRounds ,
  generateSingleRound ,
}
/* plackettLuce Not a pure module */
