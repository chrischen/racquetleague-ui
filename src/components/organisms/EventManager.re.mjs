// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Util from "../shared/Util.re.mjs";
import * as React from "react";
import * as Rating from "../../lib/Rating.re.mjs";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Core__Int from "@rescript/core/src/Core__Int.re.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.re.mjs";
import * as RoundHeader from "../molecules/RoundHeader.re.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.re.mjs";
import * as Core__String from "@rescript/core/src/Core__String.re.mjs";
import * as LangProvider from "../shared/LangProvider.re.mjs";
import * as RoundSection from "./RoundSection.re.mjs";
import * as LucideReact from "lucide-react";
import * as DrawGenerator from "../molecules/DrawGenerator.re.mjs";
import * as PlayerCheckin from "./PlayerCheckin.re.mjs";
import * as JsxRuntime from "react/jsx-runtime";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";
import * as PlayerSettingsModal from "./PlayerSettingsModal.re.mjs";
import * as TeamManagementModal from "./TeamManagementModal.re.mjs";
import * as AddGuestPlayersModal from "./AddGuestPlayersModal.re.mjs";
import * as RescriptRelay_Fragment from "rescript-relay/src/RescriptRelay_Fragment.re.mjs";
import * as RescriptRelay_Mutation from "rescript-relay/src/RescriptRelay_Mutation.re.mjs";
import * as SeedAdjustmentTimeline from "./SeedAdjustmentTimeline.re.mjs";
import * as EventManagerPersistence from "./EventManagerPersistence.re.mjs";
import * as EventManager_event_graphql from "../../__generated__/EventManager_event_graphql.re.mjs";
import * as EventManagerRsvpsRefetchQuery_graphql from "../../__generated__/EventManagerRsvpsRefetchQuery_graphql.re.mjs";
import * as EventManagerSubmitMatchMutation_graphql from "../../__generated__/EventManagerSubmitMatchMutation_graphql.re.mjs";

import { t, plural } from '@lingui/macro'
;

var convertVariables = EventManagerSubmitMatchMutation_graphql.Internal.convertVariables;

var convertResponse = EventManagerSubmitMatchMutation_graphql.Internal.convertResponse;

var convertWrapRawResponse = EventManagerSubmitMatchMutation_graphql.Internal.convertWrapRawResponse;

var commitMutation = RescriptRelay_Mutation.commitMutation(convertVariables, EventManagerSubmitMatchMutation_graphql.node, convertResponse, convertWrapRawResponse);

var use = RescriptRelay_Mutation.useMutation(convertVariables, EventManagerSubmitMatchMutation_graphql.node, convertResponse, convertWrapRawResponse);

var CreateLeagueMatchMutation = {
  Operation: undefined,
  Types: undefined,
  convertVariables: convertVariables,
  convertResponse: convertResponse,
  convertWrapRawResponse: convertWrapRawResponse,
  commitMutation: commitMutation,
  use: use
};

var getConnectionNodes = EventManager_event_graphql.Utils.getConnectionNodes;

var convertFragment = EventManager_event_graphql.Internal.convertFragment;

function use$1(fRef) {
  return RescriptRelay_Fragment.useFragment(EventManager_event_graphql.node, convertFragment, fRef);
}

function useOpt(fRef) {
  return RescriptRelay_Fragment.useFragmentOpt(fRef !== undefined ? Caml_option.some(Caml_option.valFromOption(fRef)) : undefined, EventManager_event_graphql.node, convertFragment);
}

var makeRefetchVariables = EventManagerRsvpsRefetchQuery_graphql.Types.makeRefetchVariables;

var convertRefetchVariables = EventManagerRsvpsRefetchQuery_graphql.Internal.convertVariables;

function useRefetchable(fRef) {
  return RescriptRelay_Fragment.useRefetchableFragment(EventManager_event_graphql.node, convertFragment, convertRefetchVariables, fRef);
}

function usePagination(fRef) {
  return RescriptRelay_Fragment.usePaginationFragment(EventManager_event_graphql.node, fRef, convertFragment, convertRefetchVariables);
}

function useBlockingPagination(fRef) {
  return RescriptRelay_Fragment.useBlockingPaginationFragment(EventManager_event_graphql.node, fRef, convertFragment, convertRefetchVariables);
}

var Fragment_gender_decode = EventManager_event_graphql.Utils.gender_decode;

var Fragment_gender_fromString = EventManager_event_graphql.Utils.gender_fromString;

var Fragment = {
  getConnectionNodes: getConnectionNodes,
  gender_decode: Fragment_gender_decode,
  gender_fromString: Fragment_gender_fromString,
  Types: undefined,
  Operation: undefined,
  convertFragment: convertFragment,
  use: use$1,
  useOpt: useOpt,
  makeRefetchVariables: makeRefetchVariables,
  convertRefetchVariables: convertRefetchVariables,
  useRefetchable: useRefetchable,
  usePagination: usePagination,
  useBlockingPagination: useBlockingPagination
};

function EventManager$OverallAverageQualityDebug(props) {
  var rounds = props.rounds;
  var match = Core__Array.reduce(rounds, [
        0,
        0,
        0,
        0
      ], (function (param, roundMatches) {
          var court1Acc = param[2];
          var match = Core__Array.reduceWithIndex(roundMatches, [
                param[1],
                param[3]
              ], (function (param, param$1, index) {
                  var match = param$1.match;
                  var court1Acc = param[1];
                  var quality = Rating.Rating.predictDraw([
                        match[0].map(function (p) {
                              return p.rating;
                            }),
                        match[1].map(function (p) {
                              return p.rating;
                            })
                      ]);
                  var newCourt1Acc = index === 0 ? court1Acc + quality : court1Acc;
                  return [
                          param[0] + quality,
                          newCourt1Acc
                        ];
                }));
          var court1Count = roundMatches.length > 0 ? court1Acc + 1 | 0 : court1Acc;
          return [
                  param[0] + roundMatches.length | 0,
                  match[0],
                  court1Count,
                  match[1]
                ];
        }));
  var court1Matches = match[2];
  var totalMatches = match[0];
  var averageQuality = totalMatches > 0 ? match[1] / totalMatches : 0.0;
  var court1AverageQuality = court1Matches > 0 ? match[3] / court1Matches : 0.0;
  var qualityPercent = averageQuality * 100.0;
  var court1QualityPercent = court1AverageQuality * 100.0;
  return JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx("div", {
                      children: "Overall Match Quality Across All Rounds",
                      className: "text-sm font-semibold text-blue-900"
                    }),
                JsxRuntime.jsx("div", {
                      children: qualityPercent.toFixed(1) + "%",
                      className: "text-lg font-bold text-blue-700 mt-1"
                    }),
                JsxRuntime.jsx("div", {
                      children: totalMatches.toString() + " total matches across " + rounds.length.toString() + " rounds",
                      className: "text-xs text-blue-600 mt-1"
                    }),
                JsxRuntime.jsxs("div", {
                      children: [
                        JsxRuntime.jsx("div", {
                              children: "Court 1 Average Quality",
                              className: "text-sm font-semibold text-blue-900"
                            }),
                        JsxRuntime.jsx("div", {
                              children: court1QualityPercent.toFixed(1) + "%",
                              className: "text-lg font-bold text-blue-700 mt-1"
                            }),
                        JsxRuntime.jsx("div", {
                              children: court1Matches.toString() + " matches on court 1",
                              className: "text-xs text-blue-600 mt-1"
                            })
                      ],
                      className: "mt-3 pt-3 border-t border-blue-200"
                    })
              ],
              className: "mb-4 p-4 bg-blue-50 border border-blue-200 rounded-lg"
            });
}

var OverallAverageQualityDebug = {
  make: EventManager$OverallAverageQualityDebug
};

function EventManager(props) {
  var __debug = props.debug;
  var debug = __debug !== undefined ? __debug : false;
  var data = use$1(props.event);
  var match = use();
  var commitMutationCreateLeagueMatch = match[0];
  var eventTags = Core__Option.getOr(data.tags, []);
  var eventNamespace = eventTags.includes("comp") ? "doubles:comp" : "doubles:rec";
  var eventStartTime = Core__Option.getOr(Core__Option.map(data.startDate, Util.Datetime.toDate), new Date());
  var submitMatch = function (match, score, activitySlug, matchId, createdAt) {
    var match$1 = Rating.Match.getWinners(match, score);
    var winnerScore = match$1[1];
    var winnerIds = match$1[0];
    var match$2 = Rating.Match.getLosers(match, score);
    var loserScore = match$2[1];
    var loserIds = match$2[0];
    return new Promise((function (resolve, reject) {
                  commitMutationCreateLeagueMatch({
                        matchInput: {
                          activitySlug: activitySlug,
                          doublesMatch: {
                            createdAt: Util.Datetime.fromDate(createdAt),
                            losers: loserIds,
                            score: [
                              winnerScore,
                              loserScore
                            ],
                            winners: winnerIds
                          },
                          namespace: eventNamespace,
                          syncId: matchId
                        }
                      }, undefined, undefined, undefined, (function (param, errs) {
                          if (errs !== undefined) {
                            console.log(errs);
                            return ;
                          } else {
                            return resolve();
                          }
                        }), (function (e) {
                          reject(e);
                        }), undefined);
                }));
  };
  var match$1 = React.useState(function () {
        return debug;
      });
  var setDebugMode = match$1[1];
  var debugMode = match$1[0];
  var match$2 = React.useState(function () {
        return "Idle";
      });
  var setSyncState = match$2[1];
  var syncState = match$2[0];
  var match$3 = React.useState(function () {
        return 0;
      });
  var setSyncProgress = match$3[1];
  React.useEffect((function () {
          switch (syncState) {
            case "Idle" :
            case "Syncing" :
                return ;
            case "Success" :
            case "Error" :
                break;
            
          }
          var timeoutId = setTimeout((function () {
                  setSyncState(function (param) {
                        return "Idle";
                      });
                  setSyncProgress(function (param) {
                        return 0;
                      });
                }), 2000);
          return (function () {
                    clearTimeout(timeoutId);
                  });
        }), [syncState]);
  var match$4 = React.useState(function () {
        return [];
      });
  var setGuestPlayers = match$4[1];
  var guestPlayers = match$4[0];
  var match$5 = React.useState(function () {
        return 9000;
      });
  var setNextGuestId = match$5[1];
  var nextGuestId = match$5[0];
  var match$6 = React.useState(function () {
        return false;
      });
  var setShowAddGuestsModal = match$6[1];
  var match$7 = React.useState(function () {
        return {};
      });
  var setPlayerOverrides = match$7[1];
  var playerOverrides = match$7[0];
  var players = React.useMemo((function () {
          return Core__Array.filterMap(Core__Option.getOr(Core__Option.flatMap(data.rsvps, (function (rsvps) {
                                      return rsvps.edges;
                                    })), []), (function (edge) {
                              return Core__Option.flatMap(Core__Option.flatMap(edge, (function (edge) {
                                                return edge.node;
                                              })), (function (rsvp) {
                                            var user = rsvp.user;
                                            if (user === undefined) {
                                              return ;
                                            }
                                            var override = Js_dict.get(playerOverrides, user.id);
                                            var overrideName = Core__Option.flatMap(override, (function (o) {
                                                    return o.name;
                                                  }));
                                            var overrideGender = Core__Option.flatMap(override, (function (o) {
                                                    return o.gender;
                                                  }));
                                            var overridePaid = Core__Option.flatMap(override, (function (o) {
                                                    return o.paid;
                                                  }));
                                            var rating = rsvp.rating;
                                            var match = rating !== undefined ? [
                                                Core__Option.getOr(rating.mu, 25.0),
                                                Core__Option.getOr(rating.sigma, 8.333),
                                                Core__Option.getOr(rating.ordinal, 0.0)
                                              ] : [
                                                25.0,
                                                8.333,
                                                0.0
                                              ];
                                            var match$1 = user.gender;
                                            var tmp;
                                            tmp = match$1 !== undefined && (match$1 === "female" || match$1 === "male") && match$1 === "female" ? "Female" : "Male";
                                            return {
                                                    data: rsvp,
                                                    id: user.id,
                                                    intId: 0,
                                                    name: Core__Option.getOr(overrideName, Core__Option.getOr(user.lineUsername, "Unknown")),
                                                    rating: {
                                                      mu: match[0],
                                                      sigma: match[1]
                                                    },
                                                    ratingOrdinal: match[2],
                                                    paid: Core__Option.getOr(overridePaid, false),
                                                    gender: Core__Option.getOr(overrideGender, tmp),
                                                    count: 0
                                                  };
                                          }));
                            })).concat(guestPlayers).toSorted(function (a, b) {
                        var ratingDiff = b.rating.mu - a.rating.mu;
                        if (ratingDiff !== 0) {
                          return ratingDiff;
                        } else {
                          return Core__String.compare(a.id, b.id);
                        }
                      }).map(function (player, i) {
                      return {
                              data: player.data,
                              id: player.id,
                              intId: i + 1 | 0,
                              name: player.name,
                              rating: player.rating,
                              ratingOrdinal: player.ratingOrdinal,
                              paid: player.paid,
                              gender: player.gender,
                              count: player.count
                            };
                    });
        }), [
        data.rsvps,
        guestPlayers,
        playerOverrides,
        nextGuestId
      ]);
  var match$8 = React.useState(function () {
        return [];
      });
  var setRounds = match$8[1];
  var rounds = match$8[0];
  var match$9 = React.useState(function () {
        return false;
      });
  var setIsDirty = match$9[1];
  var isDirty = match$9[0];
  var match$10 = React.useState(function () {
        return new Set();
      });
  var setCheckedInPlayerIds = match$10[1];
  var checkedInPlayerIds = match$10[0];
  var match$11 = React.useState(function () {
        return 0;
      });
  var setCurrentRoundInt = match$11[1];
  var currentRoundInt = match$11[0];
  var currentRoundRef = React.useRef(null);
  var match$12 = React.useState(function () {
        return 3;
      });
  var setCourtCount = match$12[1];
  var courtCount = match$12[0];
  var match$13 = React.useState(function () {
        return "CompetitivePlus";
      });
  var setStrategy = match$13[1];
  var strategy = match$13[0];
  var match$14 = React.useState(function () {
        return [];
      });
  var setRatingAdjustmentHistory = match$14[1];
  var ratingAdjustmentHistory = match$14[0];
  var match$15 = React.useState(function () {
        
      });
  var setPendingRoundReset = match$15[1];
  var pendingRoundReset = match$15[0];
  var match$16 = React.useState(function () {
        return Util.NonEmptyArray.empty;
      });
  var setTeams = match$16[1];
  var teams = match$16[0];
  var match$17 = React.useState(function () {
        return Util.NonEmptyArray.empty;
      });
  var setAntiTeams = match$17[1];
  var antiTeams = match$17[0];
  var match$18 = React.useState(function () {
        return false;
      });
  var setTeamManagementOpen = match$18[1];
  var match$19 = React.useState(function () {
        
      });
  var setPlayerSettingsOpen = match$19[1];
  var teamConstraints = React.useMemo((function () {
          var teamsArray = Util.NonEmptyArray.toArray(teams);
          if (teamsArray.length > 0) {
            return teamsArray.map(Rating.Team.toSet);
          }
          
        }), [teams]);
  var avoidAllPlayers = React.useMemo((function () {
          return Util.NonEmptyArray.toArray(antiTeams);
        }), [antiTeams]);
  var futureRoundsHaveScores = React.useMemo((function () {
          return rounds.some(function (round, index) {
                      if (index >= currentRoundInt) {
                        return round.some(function (match) {
                                    return Core__Option.isSome(match.score);
                                  });
                      } else {
                        return false;
                      }
                    });
        }), [
        rounds,
        currentRoundInt
      ]);
  React.useEffect((function () {
          Core__Option.forEach(Caml_option.nullable_to_opt(currentRoundRef.current), (function (element) {
                  element.scrollIntoView({
                        behavior: "smooth",
                        block: "center"
                      });
                }));
        }), [currentRoundInt]);
  React.useEffect((function () {
          var storedCourtCount = EventManagerPersistence.loadCourtCount(data.id);
          setCourtCount(function (param) {
                return storedCourtCount;
              });
          var storedCheckedInIds = EventManagerPersistence.loadCheckedInPlayerIds(data.id);
          if (storedCheckedInIds.length > 0) {
            setCheckedInPlayerIds(function (param) {
                  return new Set(storedCheckedInIds);
                });
          }
          var storedCurrentRound = EventManagerPersistence.loadCurrentRound(data.id);
          setCurrentRoundInt(function (param) {
                return storedCurrentRound;
              });
          var storedHistory = EventManagerPersistence.loadRatingAdjustmentHistory(data.id);
          setRatingAdjustmentHistory(function (param) {
                return storedHistory;
              });
          var storedTeams = EventManagerPersistence.loadTeams(data.id);
          if (storedTeams.length > 0) {
            setTeams(function (param) {
                  return Util.NonEmptyArray.fromArray(storedTeams);
                });
          }
          var storedAntiTeams = EventManagerPersistence.loadAntiTeams(data.id);
          if (storedAntiTeams.length > 0) {
            setAntiTeams(function (param) {
                  return Util.NonEmptyArray.fromArray(storedAntiTeams);
                });
          }
          var storedPlayerOverrides = EventManagerPersistence.loadPlayerOverrides(data.id);
          setPlayerOverrides(function (param) {
                return storedPlayerOverrides;
              });
          var storedGuestPlayers = EventManagerPersistence.loadGuestPlayers(data.id);
          if (storedGuestPlayers.length > 0) {
            setGuestPlayers(function (param) {
                  return storedGuestPlayers;
                });
            var maxGuestId = Core__Array.reduce(storedGuestPlayers, 8999, (function (max, player) {
                    var playerId = Core__Option.getOr(Core__Int.fromString(player.id, undefined), 0);
                    if (playerId > max) {
                      return playerId;
                    } else {
                      return max;
                    }
                  }));
            setNextGuestId(function (param) {
                  return maxGuestId + 1 | 0;
                });
          }
          var rsvpMap = Js_dict.fromArray(Core__Array.filterMap(getConnectionNodes(data.rsvps), (function (rsvp) {
                      return Core__Option.map(Core__Option.map(rsvp.user, (function (u) {
                                        return u.id;
                                      })), (function (userId) {
                                    return [
                                            userId,
                                            rsvp
                                          ];
                                  }));
                    })));
          var rawMatches = EventManagerPersistence.loadMatchesFromDb(data.id, rsvpMap);
          var roundsMap = new Map();
          rawMatches.forEach(function (param) {
                var roundIndex = param[3];
                var roundMatches = Core__Option.getOr(roundsMap.get(roundIndex), []);
                roundsMap.set(roundIndex, roundMatches.concat([[
                            param[0],
                            param[1],
                            param[2],
                            param[4],
                            param[5]
                          ]]));
              });
          var maxRound = Core__Array.reduce(rawMatches, 0, (function (max, param) {
                  var roundIndex = param[3];
                  if (roundIndex > max) {
                    return roundIndex;
                  } else {
                    return max;
                  }
                }));
          var loadedRounds = [];
          for(var i = 0; i <= maxRound; ++i){
            var roundData = Core__Option.getOr(roundsMap.get(i), []);
            var round = Core__Array.filterMap(roundData, (function (param) {
                    var team2Players = param[2];
                    var team1Players = param[1];
                    if (team1Players.length > 0 && team2Players.length > 0) {
                      return {
                              id: param[0],
                              match: [
                                team1Players,
                                team2Players
                              ],
                              score: param[3],
                              createdAt: param[4]
                            };
                    }
                    
                  }));
            loadedRounds.push(round);
          }
          if (loadedRounds.length > 0 && loadedRounds.some(function (round) {
                  return round.length > 0;
                })) {
            setRounds(function (param) {
                  return loadedRounds;
                });
            if (currentRoundInt < 0 || currentRoundInt > loadedRounds.length) {
              var newRoundInt = loadedRounds.length;
              setCurrentRoundInt(function (param) {
                    return newRoundInt;
                  });
              EventManagerPersistence.saveCurrentRound(data.id, newRoundInt);
            }
            
          }
          
        }), [data.id]);
  var updateRounds = function (updater) {
    setRounds(function (currentRounds) {
          var newRounds = updater(currentRounds);
          EventManagerPersistence.syncRoundsToDb(data.id, newRounds);
          return newRounds;
        });
  };
  var playersWithCounts = React.useMemo((function () {
          var adjustmentsUpToCurrent = ratingAdjustmentHistory.filter(function (adj) {
                return adj.appliedAtRound < currentRoundInt;
              });
          return Rating.toPlayerStateWithAdjustments(rounds.slice(0, currentRoundInt), players, adjustmentsUpToCurrent);
        }), [
        rounds,
        currentRoundInt,
        ratingAdjustmentHistory,
        players
      ]);
  var checkedInPlayers = React.useMemo((function () {
          return playersWithCounts.filter(function (p) {
                      return checkedInPlayerIds.has(p.id);
                    });
        }), [
        playersWithCounts,
        checkedInPlayerIds
      ]);
  var playersCache = React.useMemo((function () {
          return Js_dict.fromArray(playersWithCounts.map(function (p) {
                          return [
                                  p.id,
                                  p
                                ];
                        }));
        }), [playersWithCounts]);
  React.useEffect((function () {
          Core__Option.forEach(pendingRoundReset, (function (roundIndex) {
                  if (roundIndex >= 0) {
                    console.log("Regenerating round " + (roundIndex + 1 | 0).toString() + " after seed adjustment");
                    updateRounds(function (currentRounds) {
                          var adjustmentsUpToCurrentRound = ratingAdjustmentHistory.filter(function (adj) {
                                return adj.appliedAtRound <= roundIndex;
                              });
                          var playersForReset = Rating.toPlayerStateWithAdjustments(currentRounds.slice(0, roundIndex), players, adjustmentsUpToCurrentRound).filter(function (p) {
                                return checkedInPlayerIds.has(p.id);
                              });
                          var newRound = Rating.generateSingleRound(roundIndex, currentRounds, playersForReset, strategy, courtCount, teamConstraints, avoidAllPlayers, undefined, eventStartTime);
                          if (newRound !== undefined) {
                            return currentRounds.map(function (round, idx) {
                                        if (idx === roundIndex) {
                                          return newRound;
                                        } else {
                                          return round;
                                        }
                                      });
                          } else {
                            return currentRounds;
                          }
                        });
                  }
                  setPendingRoundReset(function (param) {
                        
                      });
                }));
        }), [
        pendingRoundReset,
        ratingAdjustmentHistory,
        players,
        checkedInPlayerIds,
        strategy,
        courtCount
      ]);
  React.useEffect((function () {
          if (!(isDirty && currentRoundInt > -1)) {
            return ;
          }
          var shouldAutoRegenerate;
          switch (strategy) {
            case "RoundRobin" :
            case "Random" :
            case "DUPR" :
                shouldAutoRegenerate = false;
                break;
            default:
              shouldAutoRegenerate = true;
          }
          if (shouldAutoRegenerate && !futureRoundsHaveScores) {
            console.log("Auto-regenerating future rounds after current round changes");
            updateRounds(function (currentRounds) {
                  var pastAndCurrentRounds = currentRounds.filter(function (param, i) {
                        return (i + 1 | 0) <= currentRoundInt;
                      });
                  var newRounds = Rating.generateRounds(currentRoundInt + 1 | 0, 10, checkedInPlayers, pastAndCurrentRounds, strategy, courtCount, teamConstraints, undefined, undefined, eventStartTime, undefined);
                  return pastAndCurrentRounds.concat(newRounds);
                });
            setIsDirty(function (param) {
                  return false;
                });
            return ;
          }
          
        }), [isDirty]);
  var handleResetRound = function (roundIndex, genderMixedOpt) {
    var genderMixed = genderMixedOpt !== undefined ? genderMixedOpt : false;
    var adjustmentsUpToCurrentRound = ratingAdjustmentHistory.filter(function (adj) {
          return adj.appliedAtRound <= roundIndex;
        });
    var playersForReset = Rating.toPlayerStateWithAdjustments(rounds.slice(0, roundIndex), players, adjustmentsUpToCurrentRound).filter(function (p) {
          return checkedInPlayerIds.has(p.id);
        });
    Core__Option.forEach(Rating.generateSingleRound(roundIndex, rounds, playersForReset, strategy, courtCount, teamConstraints, avoidAllPlayers, genderMixed, eventStartTime), (function (newRound) {
            updateRounds(function (rounds) {
                  return rounds.map(function (round, idx) {
                              if (idx === roundIndex) {
                                return newRound;
                              } else {
                                return round;
                              }
                            });
                });
          }));
  };
  var adjustPlayerSeeds = function (sortedPlayers) {
    setRatingAdjustmentHistory(function (prevHistory) {
          var originalMuMap = Js_dict.fromArray(checkedInPlayers.map(function (p) {
                    return [
                            p.id,
                            p.rating.mu
                          ];
                  }));
          var targetRound = currentRoundInt - 1 | 0;
          var timestamp = Date.now();
          var newAdjustments = [];
          var adjustedPlayerIds = new Set();
          sortedPlayers.forEach(function (param) {
                var adjustedMu = param[1];
                var playerId = param[0];
                Core__Option.forEach(Js_dict.get(originalMuMap, playerId), (function (originalMu) {
                        var differential = adjustedMu - originalMu;
                        if (differential !== 0.0) {
                          adjustedPlayerIds.add(playerId);
                          newAdjustments.push({
                                playerId: playerId,
                                differential: differential,
                                appliedAtRound: targetRound,
                                timestamp: timestamp
                              });
                          return ;
                        }
                        
                      }));
              });
          var filteredHistory = prevHistory.filter(function (adj) {
                return !(adj.appliedAtRound === targetRound && adjustedPlayerIds.has(adj.playerId));
              });
          var updatedHistory = filteredHistory.concat(newAdjustments);
          EventManagerPersistence.saveRatingAdjustmentHistory(data.id, updatedHistory);
          setIsDirty(function (param) {
                return true;
              });
          return updatedHistory;
        });
    if (currentRoundInt > 0) {
      return setPendingRoundReset(function (param) {
                  return currentRoundInt - 1 | 0;
                });
    }
    
  };
  var handleMatchCompleted = function (matchId, completedMatch) {
    var score = completedMatch[1];
    var match = completedMatch[0];
    if (Core__Option.isSome(score)) {
      var exit = 0;
      switch (strategy) {
        case "CompetitivePlus" :
        case "Competitive" :
        case "Mixed" :
            exit = 1;
            break;
        default:
          
      }
      if (exit === 1) {
        setIsDirty(function (param) {
              return true;
            });
      }
      
    }
    updateRounds(function (rounds) {
          return rounds.map(function (round) {
                      var hasMatch = round.some(function (m) {
                            return m.id === matchId;
                          });
                      if (hasMatch) {
                        return round.map(function (m) {
                                    if (m.id !== matchId) {
                                      return m;
                                    }
                                    var shouldUpdateCreatedAt = Core__Option.isNone(m.score) && Core__Option.isSome(score);
                                    var updatedCreatedAt = shouldUpdateCreatedAt ? new Date() : m.createdAt;
                                    console.log("Setting createdAt");
                                    console.log(updatedCreatedAt);
                                    return {
                                            id: m.id,
                                            match: match,
                                            score: score,
                                            createdAt: updatedCreatedAt
                                          };
                                  });
                      } else {
                        return round;
                      }
                    });
        });
  };
  var handleMatchCanceled = function (matchId) {
    updateRounds(function (rounds) {
          return rounds.map(function (round, param) {
                      var hasMatch = round.some(function (m) {
                            return m.id === matchId;
                          });
                      if (hasMatch) {
                        setIsDirty(function (param) {
                              return true;
                            });
                        return round.filter(function (m) {
                                    return m.id !== matchId;
                                  });
                      } else {
                        return round;
                      }
                    });
        });
  };
  var handleToggleCheckin = function (playerId) {
    setIsDirty(function (param) {
          return true;
        });
    setCheckedInPlayerIds(function (prev) {
          var newSet = new Set(Array.from(prev.values()));
          if (prev.has(playerId)) {
            newSet.delete(playerId);
          } else {
            newSet.add(playerId);
          }
          var playerIdsArray = Array.from(newSet.values());
          EventManagerPersistence.saveCheckedInPlayerIds(data.id, playerIdsArray);
          return newSet;
        });
  };
  var handleRebalanceRound = function (roundIndex) {
    var currentRoundPlayerIds = Core__Option.getOr(Core__Option.map(rounds[roundIndex], (function (roundMatches) {
                return new Set(roundMatches.flatMap(function (param) {
                                  return Rating.Match.players(param.match);
                                }).map(function (p) {
                                return p.id;
                              }));
              })), new Set());
    var adjustmentsUpToCurrentRound = ratingAdjustmentHistory.filter(function (adj) {
          return adj.appliedAtRound <= roundIndex;
        });
    var playersBeforeRound = Rating.toPlayerStateWithAdjustments(rounds.slice(0, roundIndex), players, adjustmentsUpToCurrentRound);
    var currentRoundPlayers = playersBeforeRound.filter(function (p) {
          return currentRoundPlayerIds.has(p.id);
        });
    Core__Option.forEach(Rating.generateSingleRound(roundIndex, rounds, currentRoundPlayers, "CompetitivePlus", courtCount, teamConstraints, avoidAllPlayers, undefined, eventStartTime), (function (newRound) {
            updateRounds(function (rounds) {
                  return rounds.map(function (round, idx) {
                              if (idx === roundIndex) {
                                return newRound;
                              } else {
                                return round;
                              }
                            });
                });
          }));
  };
  var handleRebalanceMatch = function (roundIndex, matchId) {
    Core__Option.forEach(Core__Option.flatMap(rounds[roundIndex], (function (roundMatches) {
                return roundMatches.find(function (param) {
                            return param.id === matchId;
                          });
              })), (function (param) {
            var matchPlayers = Rating.Match.players(param.match);
            var matchPlayerIds = new Set(matchPlayers.map(function (p) {
                      return p.id;
                    }));
            var adjustmentsUpToCurrentRound = ratingAdjustmentHistory.filter(function (adj) {
                  return adj.appliedAtRound <= roundIndex;
                });
            var playersBeforeRound = Rating.toPlayerStateWithAdjustments(rounds.slice(0, roundIndex), players, adjustmentsUpToCurrentRound);
            var matchPlayersWithState = playersBeforeRound.filter(function (p) {
                  return matchPlayerIds.has(p.id);
                });
            Core__Option.forEach(Rating.generateSingleRound(roundIndex, rounds, matchPlayersWithState, strategy, 1, teamConstraints, [], undefined, eventStartTime), (function (newRound) {
                    Core__Option.forEach(newRound[0], (function (newMatchEntity) {
                            updateRounds(function (rounds) {
                                  return rounds.map(function (round, idx) {
                                              if (idx === roundIndex) {
                                                return round.map(function (matchEntity) {
                                                            if (matchEntity.id === matchId) {
                                                              return {
                                                                      id: matchEntity.id,
                                                                      match: newMatchEntity.match,
                                                                      score: matchEntity.score,
                                                                      createdAt: matchEntity.createdAt
                                                                    };
                                                            } else {
                                                              return matchEntity;
                                                            }
                                                          });
                                              } else {
                                                return round;
                                              }
                                            });
                                });
                          }));
                  }));
          }));
  };
  var handleGenerateDraws = function () {
    if (rounds.length === 0 || currentRoundInt === 0) {
      var pastAndCurrentRounds = rounds.filter(function (param, i) {
            return (i + 1 | 0) <= currentRoundInt;
          });
      var newRounds = Rating.generateRounds(1, 10, checkedInPlayers, pastAndCurrentRounds, strategy, courtCount, teamConstraints, avoidAllPlayers, undefined, eventStartTime, undefined);
      updateRounds(function (param) {
            return newRounds;
          });
      setCurrentRoundInt(function (param) {
            return 1;
          });
      EventManagerPersistence.saveCurrentRound(data.id, 1);
      setRatingAdjustmentHistory(function (prevHistory) {
            var filteredHistory = prevHistory.filter(function (adj) {
                  return adj.appliedAtRound < 0;
                });
            EventManagerPersistence.saveRatingAdjustmentHistory(data.id, filteredHistory);
            return filteredHistory;
          });
      return setIsDirty(function (param) {
                  return false;
                });
    }
    var pastAndCurrentRounds$1 = rounds.filter(function (param, i) {
          return (i + 1 | 0) <= currentRoundInt;
        });
    var newRounds$1 = Rating.generateRounds(currentRoundInt + 1 | 0, 10, checkedInPlayers, pastAndCurrentRounds$1, strategy, courtCount, teamConstraints, avoidAllPlayers, undefined, eventStartTime, undefined);
    updateRounds(function (param) {
          return pastAndCurrentRounds$1.concat(newRounds$1);
        });
    setRatingAdjustmentHistory(function (prevHistory) {
          var filteredHistory = prevHistory.filter(function (adj) {
                return adj.appliedAtRound < currentRoundInt;
              });
          EventManagerPersistence.saveRatingAdjustmentHistory(data.id, filteredHistory);
          return filteredHistory;
        });
    setIsDirty(function (param) {
          return false;
        });
  };
  var handleCourtCountChange = function (count) {
    setCourtCount(function (param) {
          return count;
        });
    setIsDirty(function (param) {
          return true;
        });
    EventManagerPersistence.saveCourtCount(data.id, count);
  };
  var handleAdvanceRound = function () {
    if (currentRoundInt >= rounds.length) {
      return ;
    }
    var newRoundInt = currentRoundInt + 1 | 0;
    setCurrentRoundInt(function (param) {
          return newRoundInt;
        });
    EventManagerPersistence.saveCurrentRound(data.id, newRoundInt);
  };
  var handlePreviousRound = function () {
    if (currentRoundInt <= 0) {
      return ;
    }
    var newRoundInt = currentRoundInt - 1 | 0;
    setCurrentRoundInt(function (param) {
          return newRoundInt;
        });
    EventManagerPersistence.saveCurrentRound(data.id, newRoundInt);
  };
  var handleSyncScores = async function () {
    setSyncState(function (param) {
          return "Syncing";
        });
    setSyncProgress(function (param) {
          return 0;
        });
    var activitySlug = Core__Option.flatMap(data.activity, (function (a) {
            return a.slug;
          }));
    if (activitySlug !== undefined) {
      var matchesWithScores = Core__Array.filterMap(rounds.flatMap(function (round) {
                return round;
              }), (function (param) {
              var createdAt = param.createdAt;
              var match = param.match;
              var id = param.id;
              return Core__Option.map(param.score, (function (scoreValue) {
                            return [
                                    id,
                                    match,
                                    scoreValue,
                                    createdAt
                                  ];
                          }));
            }));
      var totalMatches = matchesWithScores.length;
      if (totalMatches === 0) {
        console.log("No scored matches to sync");
        return setSyncState(function (param) {
                    return "Success";
                  });
      }
      var results = [];
      for(var i = 0; i < totalMatches; ++i){
        var match = matchesWithScores[i];
        try {
          await submitMatch(match[1], match[2], activitySlug, match[0], match[3]);
          results.push({
                TAG: "Ok",
                _0: undefined
              });
          var progress = (i + 1 | 0) / totalMatches * 100;
          setSyncProgress((function(progress){
              return function (param) {
                return progress | 0;
              }
              }(progress)));
          await new Promise((function (resolve, param) {
                  setTimeout((function () {
                          resolve();
                        }), 500);
                }));
        }
        catch (raw_error){
          var error = Caml_js_exceptions.internalToOCamlException(raw_error);
          console.log("Error syncing match:", error);
          results.push({
                TAG: "Error",
                _0: undefined
              });
        }
      }
      var allSucceeded = results.every(function (result) {
            if (result.TAG === "Ok") {
              return true;
            } else {
              return false;
            }
          });
      return setSyncState(function (param) {
                  if (allSucceeded) {
                    return "Success";
                  } else {
                    return "Error";
                  }
                });
    }
    console.log("No activity slug found, cannot sync scores");
    return setSyncState(function (param) {
                return "Error";
              });
  };
  var canGoBack = currentRoundInt > 0;
  var canAdvance = currentRoundInt < rounds.length;
  var getUserFragmentRefs = function (rsvpNode) {
    return Core__Option.map(rsvpNode.user, (function (user) {
                  return user.fragmentRefs;
                }));
  };
  var hasExistingDraws = rounds.length > 0;
  var handleResetStorage = function () {
    EventManagerPersistence.clearEventData(data.id);
    setRounds(function (param) {
          return [];
        });
    setCurrentRoundInt(function (param) {
          return 0;
        });
    setCourtCount(function (param) {
          return 3;
        });
    setCheckedInPlayerIds(function (param) {
          return new Set();
        });
    setRatingAdjustmentHistory(function (param) {
          return [];
        });
    setIsDirty(function (param) {
          return false;
        });
    setTeams(function (param) {
          return Util.NonEmptyArray.empty;
        });
    setAntiTeams(function (param) {
          return Util.NonEmptyArray.empty;
        });
    setPlayerOverrides(function (param) {
          return {};
        });
  };
  var handleDeleteAdjustment = function (timestamp) {
    setRatingAdjustmentHistory(function (prevHistory) {
          var updatedHistory = prevHistory.filter(function (adj) {
                return adj.timestamp !== timestamp;
              });
          EventManagerPersistence.saveRatingAdjustmentHistory(data.id, updatedHistory);
          setIsDirty(function (param) {
                return true;
              });
          return updatedHistory;
        });
    if (currentRoundInt > 0) {
      return setPendingRoundReset(function (param) {
                  return currentRoundInt - 1 | 0;
                });
    }
    
  };
  var handleUpdatePlayer = function (updatedPlayer) {
    EventManagerPersistence.savePlayerOverride(data.id, updatedPlayer.id, updatedPlayer.name, updatedPlayer.gender, updatedPlayer.paid);
    setPlayerOverrides(function (prev) {
          var updated = {};
          Js_dict.entries(prev).forEach(function (param) {
                updated[param[0]] = param[1];
              });
          updated[updatedPlayer.id] = {
            playerId: updatedPlayer.id,
            name: updatedPlayer.name,
            gender: updatedPlayer.gender,
            paid: updatedPlayer.paid
          };
          return updated;
        });
    setIsDirty(function (param) {
          return true;
        });
    if (currentRoundInt > 0) {
      setPendingRoundReset(function (param) {
            return currentRoundInt - 1 | 0;
          });
    }
    setPlayerSettingsOpen(function (param) {
          
        });
  };
  var handleAddGuestPlayers = function (names) {
    var newGuests = names.map(function (name, index) {
          var guestId = nextGuestId + index | 0;
          return Rating.Player.makeDefaultRatingPlayer(name, "Male", guestId);
        });
    var updatedGuestPlayers = guestPlayers.concat(newGuests);
    setGuestPlayers(function (param) {
          return updatedGuestPlayers;
        });
    setNextGuestId(function (prev) {
          return prev + names.length | 0;
        });
    setCheckedInPlayerIds(function (prev) {
          var newSet = new Set(Array.from(prev.values()));
          newGuests.forEach(function (guest) {
                newSet.add(guest.id);
              });
          return newSet;
        });
    EventManagerPersistence.saveGuestPlayers(data.id, updatedGuestPlayers);
    var updatedCheckedInIds = Array.from(checkedInPlayerIds.values());
    var newGuestIds = newGuests.map(function (g) {
          return g.id;
        });
    EventManagerPersistence.saveCheckedInPlayerIds(data.id, updatedCheckedInIds.concat(newGuestIds));
    setShowAddGuestsModal(function (param) {
          return false;
        });
  };
  var teamsAsData = Util.NonEmptyArray.toArray(teams).map(function (team, index) {
        return {
                id: index,
                name: t`Team ${(index + 1 | 0).toString()}`,
                playerIds: team.map(function (p) {
                      return p.id;
                    })
              };
      });
  var tmp;
  if (hasExistingDraws) {
    var adjustmentsForRound0 = ratingAdjustmentHistory.filter(function (adj) {
          return adj.appliedAtRound === -1;
        });
    var tmp$1;
    if (rounds.length > 0) {
      var tmp$2;
      switch (syncState) {
        case "Idle" :
            tmp$2 = JsxRuntime.jsxs(JsxRuntime.Fragment, {
                  children: [
                    JsxRuntime.jsx(LucideReact.RotateCcw, {
                          className: "w-5 h-5"
                        }),
                    JsxRuntime.jsx("span", {
                          children: t`Sync Scores`
                        })
                  ]
                });
            break;
        case "Syncing" :
            tmp$2 = JsxRuntime.jsxs(JsxRuntime.Fragment, {
                  children: [
                    JsxRuntime.jsx(LucideReact.RotateCcw, {
                          className: "w-5 h-5 animate-spin"
                        }),
                    JsxRuntime.jsx("span", {
                          children: t`Syncing... ${match$3[0].toString()}%`
                        })
                  ]
                });
            break;
        case "Success" :
            tmp$2 = JsxRuntime.jsxs(JsxRuntime.Fragment, {
                  children: [
                    JsxRuntime.jsx(LucideReact.Check, {
                          className: "w-5 h-5"
                        }),
                    JsxRuntime.jsx("span", {
                          children: t`Scores Synced!`
                        })
                  ]
                });
            break;
        case "Error" :
            tmp$2 = JsxRuntime.jsxs(JsxRuntime.Fragment, {
                  children: [
                    JsxRuntime.jsx(LucideReact.AlertCircle, {
                          className: "w-5 h-5"
                        }),
                    JsxRuntime.jsx("span", {
                          children: t`Sync Failed`
                        })
                  ]
                });
            break;
        
      }
      var tmp$3;
      switch (syncState) {
        case "Idle" :
            tmp$3 = "flex items-center gap-3 px-6 py-4 rounded-xl font-semibold text-lg transition-all shadow-lg bg-blue-600 hover:bg-blue-700 text-white hover:shadow-xl";
            break;
        case "Syncing" :
            tmp$3 = "flex items-center gap-3 px-6 py-4 rounded-xl font-semibold text-lg transition-all shadow-lg bg-blue-500 text-white cursor-wait";
            break;
        case "Success" :
            tmp$3 = "flex items-center gap-3 px-6 py-4 rounded-xl font-semibold text-lg transition-all shadow-lg bg-green-600 text-white";
            break;
        case "Error" :
            tmp$3 = "flex items-center gap-3 px-6 py-4 rounded-xl font-semibold text-lg transition-all shadow-lg bg-red-600 text-white";
            break;
        
      }
      tmp$1 = JsxRuntime.jsx("div", {
            children: JsxRuntime.jsx("button", {
                  children: tmp$2,
                  className: tmp$3,
                  disabled: syncState === "Syncing",
                  onClick: (function (param) {
                      handleSyncScores();
                    })
                }),
            className: "mt-8 flex justify-center"
          });
    } else {
      tmp$1 = null;
    }
    tmp = JsxRuntime.jsxs(JsxRuntime.Fragment, {
          children: [
            JsxRuntime.jsx(RoundHeader.make, {
                  currentRound: currentRoundInt,
                  onAdvanceRound: handleAdvanceRound,
                  onPreviousRound: handlePreviousRound,
                  canAdvance: canAdvance,
                  canGoBack: canGoBack
                }),
            JsxRuntime.jsxs("div", {
                  children: [
                    debugMode && rounds.length > 0 ? JsxRuntime.jsx(EventManager$OverallAverageQualityDebug, {
                            rounds: rounds
                          }) : null,
                    currentRoundInt === 0 ? JsxRuntime.jsx(DrawGenerator.make, {
                            courtCount: courtCount,
                            checkedInPlayerCount: checkedInPlayerIds.size,
                            hasExistingDraws: rounds.length > 0,
                            strategy: strategy,
                            onStrategyChange: (function (s) {
                                setStrategy(function (param) {
                                      return s;
                                    });
                              }),
                            onGenerateDraws: handleGenerateDraws,
                            onCourtCountChange: handleCourtCountChange,
                            isInitiallyExpanded: true,
                            highlight: isDirty,
                            futureRoundsHaveScores: futureRoundsHaveScores
                          }) : null,
                    adjustmentsForRound0.length > 0 ? JsxRuntime.jsx(SeedAdjustmentTimeline.make, {
                            adjustments: adjustmentsForRound0,
                            playersCache: playersCache,
                            getUserFragmentRefs: (function (data) {
                                return Core__Option.map(data.user, (function (u) {
                                              return u.fragmentRefs;
                                            }));
                              }),
                            onDelete: (function () {
                                Core__Option.forEach(adjustmentsForRound0[0], (function (adj) {
                                        handleDeleteAdjustment(adj.timestamp);
                                      }));
                              })
                          }) : null,
                    rounds.map(function (roundMatches, roundIndex) {
                          var roundNum = roundIndex + 1 | 0;
                          var isCurrentRound = roundNum === currentRoundInt;
                          var isPastRound = roundNum < currentRoundInt;
                          var adjustmentsForRound = ratingAdjustmentHistory.filter(function (adj) {
                                return adj.appliedAtRound === roundIndex;
                              });
                          return JsxRuntime.jsxs(React.Fragment, {
                                      children: [
                                        adjustmentsForRound.length > 0 ? JsxRuntime.jsx(SeedAdjustmentTimeline.make, {
                                                adjustments: adjustmentsForRound,
                                                playersCache: playersCache,
                                                getUserFragmentRefs: (function (data) {
                                                    return Core__Option.map(data.user, (function (u) {
                                                                  return u.fragmentRefs;
                                                                }));
                                                  }),
                                                onDelete: (function () {
                                                    Core__Option.forEach(adjustmentsForRound[0], (function (adj) {
                                                            handleDeleteAdjustment(adj.timestamp);
                                                          }));
                                                  })
                                              }) : null,
                                        isCurrentRound ? JsxRuntime.jsx("div", {
                                                children: JsxRuntime.jsx(RoundSection.make, {
                                                      matches: roundMatches,
                                                      roundNumber: roundNum,
                                                      isCurrentRound: isCurrentRound,
                                                      isPastRound: isPastRound,
                                                      playersCache: playersCache,
                                                      checkedInPlayerIds: checkedInPlayerIds,
                                                      handleMatchCanceled: (function (matchId) {
                                                          handleMatchCanceled(matchId);
                                                        }),
                                                      handleMatchUpdated: (function (completedMatch, matchId) {
                                                          handleMatchCompleted(matchId, completedMatch);
                                                        }),
                                                      setMatches: (function (updateFn) {
                                                          updateRounds(function (rounds) {
                                                                return rounds.map(function (round, idx) {
                                                                            if (idx === roundIndex) {
                                                                              return updateFn(round);
                                                                            } else {
                                                                              return round;
                                                                            }
                                                                          });
                                                              });
                                                        }),
                                                      setQueue: (function (param) {
                                                          
                                                        }),
                                                      setRequiredPlayers: (function (param) {
                                                          
                                                        }),
                                                      setShowMatchSelector: (function (param) {
                                                          
                                                        }),
                                                      onRebalance: (function () {
                                                          handleRebalanceRound(roundIndex);
                                                        }),
                                                      onRebalanceMatch: (function (matchId) {
                                                          handleRebalanceMatch(roundIndex, matchId);
                                                        }),
                                                      onReset: (function (genderMixed) {
                                                          handleResetRound(roundIndex, genderMixed);
                                                        }),
                                                      debug: debugMode,
                                                      getUserFragmentRefs: getUserFragmentRefs,
                                                      allRounds: rounds
                                                    }),
                                                ref: Caml_option.some(currentRoundRef)
                                              }) : JsxRuntime.jsx(RoundSection.make, {
                                                matches: roundMatches,
                                                roundNumber: roundNum,
                                                isCurrentRound: isCurrentRound,
                                                isPastRound: isPastRound,
                                                playersCache: playersCache,
                                                checkedInPlayerIds: checkedInPlayerIds,
                                                handleMatchCanceled: (function (matchId) {
                                                    handleMatchCanceled(matchId);
                                                  }),
                                                handleMatchUpdated: (function (completedMatch, matchId) {
                                                    handleMatchCompleted(matchId, completedMatch);
                                                  }),
                                                setMatches: (function (updateFn) {
                                                    updateRounds(function (rounds) {
                                                          return rounds.map(function (round, idx) {
                                                                      if (idx === roundIndex) {
                                                                        return updateFn(round);
                                                                      } else {
                                                                        return round;
                                                                      }
                                                                    });
                                                        });
                                                  }),
                                                setQueue: (function (param) {
                                                    
                                                  }),
                                                setRequiredPlayers: (function (param) {
                                                    
                                                  }),
                                                setShowMatchSelector: (function (param) {
                                                    
                                                  }),
                                                onRebalance: (function () {
                                                    handleRebalanceRound(roundIndex);
                                                  }),
                                                onRebalanceMatch: (function (matchId) {
                                                    handleRebalanceMatch(roundIndex, matchId);
                                                  }),
                                                onReset: (function (genderMixed) {
                                                    handleResetRound(roundIndex, genderMixed);
                                                  }),
                                                debug: debugMode,
                                                getUserFragmentRefs: getUserFragmentRefs,
                                                allRounds: rounds
                                              }),
                                        isCurrentRound ? JsxRuntime.jsx(DrawGenerator.make, {
                                                courtCount: courtCount,
                                                checkedInPlayerCount: checkedInPlayerIds.size,
                                                hasExistingDraws: rounds.length > roundNum,
                                                strategy: strategy,
                                                onStrategyChange: (function (s) {
                                                    setStrategy(function (param) {
                                                          return s;
                                                        });
                                                  }),
                                                onGenerateDraws: handleGenerateDraws,
                                                onCourtCountChange: handleCourtCountChange,
                                                isInitiallyExpanded: currentRoundInt === 0,
                                                highlight: isDirty,
                                                futureRoundsHaveScores: futureRoundsHaveScores
                                              }) : null
                                      ]
                                    }, roundNum.toString());
                        }),
                    tmp$1
                  ],
                  className: "flex-1 overflow-auto p-6"
                })
          ]
        });
  } else {
    tmp = null;
  }
  return JsxRuntime.jsxs(JsxRuntime.Fragment, {
              children: [
                match$18[0] ? JsxRuntime.jsx(TeamManagementModal.make, {
                        teams: teamsAsData,
                        antiTeams: Util.NonEmptyArray.toArray(antiTeams).map(function (team, index) {
                              return {
                                      id: index,
                                      name: t`Anti-Team ${(index + 1 | 0).toString()}`,
                                      playerIds: team.map(function (p) {
                                            return p.id;
                                          })
                                    };
                            }),
                        players: playersWithCounts,
                        onSave: (function (updatedTeams, updatedAntiTeams) {
                            var newTeams = Core__Array.filterMap(updatedTeams, (function (teamData) {
                                    var teamPlayers = Core__Array.filterMap(teamData.playerIds, (function (id) {
                                            return playersWithCounts.find(function (p) {
                                                        return p.id === id;
                                                      });
                                          }));
                                    if (teamPlayers.length > 0) {
                                      return teamPlayers;
                                    }
                                    
                                  }));
                            setTeams(function (param) {
                                  return Util.NonEmptyArray.fromArray(newTeams);
                                });
                            EventManagerPersistence.saveTeams(data.id, newTeams);
                            var newAntiTeams = Core__Array.filterMap(updatedAntiTeams, (function (teamData) {
                                    var teamPlayers = Core__Array.filterMap(teamData.playerIds, (function (id) {
                                            return playersWithCounts.find(function (p) {
                                                        return p.id === id;
                                                      });
                                          }));
                                    if (teamPlayers.length > 0) {
                                      return teamPlayers;
                                    }
                                    
                                  }));
                            setAntiTeams(function (param) {
                                  return Util.NonEmptyArray.fromArray(newAntiTeams);
                                });
                            EventManagerPersistence.saveAntiTeams(data.id, newAntiTeams);
                            setTeamManagementOpen(function (param) {
                                  return false;
                                });
                            setIsDirty(function (param) {
                                  return true;
                                });
                          }),
                        onClose: (function () {
                            setTeamManagementOpen(function (param) {
                                  return false;
                                });
                          })
                      }) : null,
                Core__Option.getOr(Core__Option.map(match$19[0], (function (player) {
                            var isGuest = Core__Option.isNone(player.data);
                            if (isGuest) {
                              return JsxRuntime.jsx(PlayerSettingsModal.make, {
                                          player: player,
                                          onSave: handleUpdatePlayer,
                                          onClose: (function () {
                                              setPlayerSettingsOpen(function (param) {
                                                    
                                                  });
                                            }),
                                          onDelete: (function () {
                                              var playerId = player.id;
                                              var updatedGuestPlayers = guestPlayers.filter(function (p) {
                                                    return p.id !== playerId;
                                                  });
                                              setGuestPlayers(function (param) {
                                                    return updatedGuestPlayers;
                                                  });
                                              setCheckedInPlayerIds(function (prev) {
                                                    var newSet = new Set(Array.from(prev.values()));
                                                    newSet.delete(playerId);
                                                    return newSet;
                                                  });
                                              var updatedTeams = Util.NonEmptyArray.toArray(teams).map(function (team) {
                                                      return team.filter(function (p) {
                                                                  return p.id !== playerId;
                                                                });
                                                    }).filter(function (team) {
                                                    return team.length > 0;
                                                  });
                                              if (updatedTeams.length > 0) {
                                                setTeams(function (param) {
                                                      return Util.NonEmptyArray.fromArray(updatedTeams);
                                                    });
                                                EventManagerPersistence.saveTeams(data.id, updatedTeams);
                                              } else {
                                                setTeams(function (param) {
                                                      
                                                    });
                                                EventManagerPersistence.saveTeams(data.id, []);
                                              }
                                              var updatedAntiTeams = Util.NonEmptyArray.toArray(antiTeams).map(function (team) {
                                                      return team.filter(function (p) {
                                                                  return p.id !== playerId;
                                                                });
                                                    }).filter(function (team) {
                                                    return team.length > 0;
                                                  });
                                              if (updatedAntiTeams.length > 0) {
                                                setAntiTeams(function (param) {
                                                      return Util.NonEmptyArray.fromArray(updatedAntiTeams);
                                                    });
                                                EventManagerPersistence.saveAntiTeams(data.id, updatedAntiTeams);
                                              } else {
                                                setAntiTeams(function (param) {
                                                      
                                                    });
                                                EventManagerPersistence.saveAntiTeams(data.id, []);
                                              }
                                              EventManagerPersistence.saveGuestPlayers(data.id, updatedGuestPlayers);
                                              EventManagerPersistence.saveCheckedInPlayerIds(data.id, Array.from(checkedInPlayerIds.values()).filter(function (id) {
                                                        return id !== playerId;
                                                      }));
                                              setIsDirty(function (param) {
                                                    return true;
                                                  });
                                            })
                                        });
                            } else {
                              return JsxRuntime.jsx(PlayerSettingsModal.make, {
                                          player: player,
                                          onSave: handleUpdatePlayer,
                                          onClose: (function () {
                                              setPlayerSettingsOpen(function (param) {
                                                    
                                                  });
                                            })
                                        });
                            }
                          })), null),
                match$6[0] ? JsxRuntime.jsx(AddGuestPlayersModal.make, {
                        onAdd: handleAddGuestPlayers,
                        onClose: (function () {
                            setShowAddGuestsModal(function (param) {
                                  return false;
                                });
                          })
                      }) : null,
                JsxRuntime.jsxs("div", {
                      children: [
                        JsxRuntime.jsx("div", {
                              children: JsxRuntime.jsxs("div", {
                                    children: [
                                      JsxRuntime.jsx("h1", {
                                            children: "Sports Event Draws",
                                            className: "text-2xl font-bold"
                                          }),
                                      JsxRuntime.jsxs("div", {
                                            children: [
                                              debugMode ? JsxRuntime.jsx("button", {
                                                      children: t`Reset Storage`,
                                                      className: "px-3 py-1 text-sm font-semibold rounded bg-red-600 hover:bg-red-700 transition-colors",
                                                      onClick: (function (param) {
                                                          handleResetStorage();
                                                        })
                                                    }) : null,
                                              JsxRuntime.jsxs(LangProvider.Router.Link.make, {
                                                    to: "/event-manager-guide",
                                                    children: [
                                                      JsxRuntime.jsx(LucideReact.CircleHelp, {
                                                            className: "w-5 h-5"
                                                          }),
                                                      JsxRuntime.jsx("span", {
                                                            children: t`Help`,
                                                            className: "text-sm font-medium"
                                                          })
                                                    ],
                                                    className: "flex items-center gap-2 px-4 py-2 rounded-lg bg-slate-700 hover:bg-slate-600 transition-colors text-white no-underline"
                                                  }),
                                              JsxRuntime.jsxs("button", {
                                                    children: [
                                                      JsxRuntime.jsx(LucideReact.CircleHelp, {
                                                            className: "w-5 h-5"
                                                          }),
                                                      JsxRuntime.jsx("span", {
                                                            children: debugMode ? t`Debug: ON` : t`Debug: OFF`,
                                                            className: "text-sm font-medium"
                                                          })
                                                    ],
                                                    className: "flex items-center gap-2 px-4 py-2 rounded-lg bg-slate-700 hover:bg-slate-600 transition-colors",
                                                    onClick: (function (param) {
                                                        setDebugMode(function (prev) {
                                                              return !prev;
                                                            });
                                                      })
                                                  })
                                            ],
                                            className: "flex items-center gap-2"
                                          })
                                    ],
                                    className: "flex items-center justify-between"
                                  }),
                              className: "bg-slate-800 text-white px-6 py-4"
                            }),
                        JsxRuntime.jsx(PlayerCheckin.make, {
                              players: playersWithCounts,
                              checkedInPlayerIds: checkedInPlayerIds,
                              onToggleCheckin: handleToggleCheckin,
                              onAdjustSeeds: adjustPlayerSeeds,
                              onOpenTeamManagement: (function () {
                                  setTeamManagementOpen(function (param) {
                                        return true;
                                      });
                                }),
                              onOpenPlayerSettings: (function (player) {
                                  setPlayerSettingsOpen(function (param) {
                                        return player;
                                      });
                                }),
                              onOpenAddGuests: (function () {
                                  setShowAddGuestsModal(function (param) {
                                        return true;
                                      });
                                }),
                              getUserFragmentRefs: getUserFragmentRefs,
                              initialPlayers: players
                            }),
                        hasExistingDraws ? null : JsxRuntime.jsx(DrawGenerator.make, {
                                courtCount: courtCount,
                                checkedInPlayerCount: checkedInPlayerIds.size,
                                hasExistingDraws: false,
                                strategy: strategy,
                                onStrategyChange: (function (s) {
                                    setStrategy(function (param) {
                                          return s;
                                        });
                                  }),
                                onGenerateDraws: handleGenerateDraws,
                                onCourtCountChange: handleCourtCountChange,
                                isInitiallyExpanded: true,
                                highlight: isDirty,
                                futureRoundsHaveScores: futureRoundsHaveScores
                              }),
                        tmp
                      ],
                      className: "min-h-screen bg-slate-50 flex flex-col"
                    })
              ]
            });
}

var make = EventManager;

export {
  CreateLeagueMatchMutation ,
  Fragment ,
  OverallAverageQualityDebug ,
  make ,
}
/*  Not a pure module */
